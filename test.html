<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Stream radio stations with live metadata and album art">
    <meta name="theme-color" content="#667eea">
    <title>Radio Player</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- iOS specific tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Radio Player">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-192x192.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/icon-192x192.png">
    
    <!-- CACHE CONTROL: Prevent aggressive caching of API data -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- Load the icecast-metadata-player library from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/icecast-metadata-player@1.17.13/build/icecast-metadata-player-1.17.13.main.min.js"></script>
    
    <!-- Load HLS.js for m3u8 stream support -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    
    <!-- Load Supabase client library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <style>
        :root {
            /* Dark theme (default) */
            --bg-gradient-start: #1e1e1e;
            --bg-gradient-end: #2d2d2d;
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --text-tertiary: rgba(255, 255, 255, 0.6);
            --text-quaternary: rgba(255, 255, 255, 0.5);
            --border-color: var(--border-color);
            --border-hover: rgba(255, 255, 255, 0.4);
            --card-bg: rgba(255, 255, 255, 0.1);
            --card-hover: rgba(255, 255, 255, 0.15);
            --shadow-color: rgba(0, 0, 0, 0.5);
            --modal-bg: #2d2d2d;
            --modal-overlay: rgba(0, 0, 0, 0.7);
            --dropdown-bg: #1e1e1e;
            --input-bg: rgba(255, 255, 255, 0.05);
            --input-border: rgba(255, 255, 255, 0.2);
            --button-bg: rgba(255, 255, 255, 0.1);
            --button-hover: rgba(255, 255, 255, 0.2);
        }
        
        [data-theme="light"] {
            /* Light theme */
            --bg-gradient-start: #f5f7fa;
            --bg-gradient-end: #e8ecf1;
            --text-primary: #1a202c;
            --text-secondary: #4a5568;
            --text-tertiary: #718096;
            --text-quaternary: #a0aec0;
            --border-color: rgba(0, 0, 0, 0.15);
            --border-hover: rgba(0, 0, 0, 0.3);
            --card-bg: rgba(255, 255, 255, 0.8);
            --card-hover: rgba(255, 255, 255, 0.95);
            --shadow-color: rgba(0, 0, 0, 0.1);
            --modal-bg: #ffffff;
            --modal-overlay: rgba(0, 0, 0, 0.5);
            --dropdown-bg: #ffffff;
            --input-bg: rgba(0, 0, 0, 0.03);
            --input-border: rgba(0, 0, 0, 0.15);
            --button-bg: rgba(0, 0, 0, 0.05);
            --button-hover: rgba(0, 0, 0, 0.1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 15px;
            color: var(--text-primary);
            transition: background 0.3s ease, color 0.3s ease;
        }
        
        .player-container {
            max-width: 500px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        /* Station selector button */
        .station-selector-btn {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            font-size: 16px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .station-selector-btn:hover {
            background: var(--card-hover);
            border-color: var(--border-hover);
            transform: translateY(-2px);
        }
        
        /* Icon-only button styles */
        .icon-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            min-width: 60px;
        }
        
        .icon-btn svg {
            width: 28px;
            height: 28px;
            transition: all 0.3s;
        }
        
        /* Settings icon */
        #settingsBtn svg {
            stroke: var(--text-primary);
            fill: none;
        }
        
        /* Playlist icon */
        #playlistsBtn svg {
            fill: var(--text-primary);
            stroke: none;
        }
        
        /* Radio/Browse icon */
        #browseStationsBtn svg {
            fill: var(--text-primary);
            stroke: none;
        }
        
        /* Favorite/Most Played icon */
        #mostPlayedBtn svg {
            fill: var(--text-primary);
            stroke: none;
        }
        
        /* Recent icon */
        #recentStationsBtn svg {
            fill: var(--text-primary);
            stroke: none;
        }
        
        .icon-btn:hover svg {
            transform: scale(1.1);
        }
        
        /* Play/Pause control buttons */
        .control-icon-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 70px;
            height: 70px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .control-icon-btn svg {
            width: 32px;
            height: 32px;
            transition: all 0.3s;
        }
        
        .control-icon-btn.btn-play {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .control-icon-btn.btn-play svg {
            fill: white;
            stroke: white;
        }
        
        .control-icon-btn.btn-play:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 6px 30px rgba(102, 126, 234, 0.5);
        }
        
        .control-icon-btn.btn-pause {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .control-icon-btn.btn-pause svg {
            fill: transparent;
            stroke: white;
        }
        
        .control-icon-btn.btn-pause:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 6px 30px rgba(245, 87, 108, 0.5);
        }
        
        .control-icon-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Station display with info */
        .station-display {
            width: 100%;
            padding: 20px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .station-display-icon {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            object-fit: cover;
            background: var(--button-bg);
            flex-shrink: 0;
        }
        
        .station-display-info {
            flex: 1;
            text-align: left;
        }
        
        .station-display-name {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 6px;
            color: var(--text-primary);
        }
        
        
        .station-display-details {
            font-size: 13px;
            color: var(--text-quaternary);
            margin-top: 4px;
        }
        
        .station-display-change {
            font-size: 12px;
            color: var(--text-quaternary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            flex-shrink: 0;
        }
        
        /* Album art container */
        .artwork-container {
            width: 100%;
            max-width: 100%;
            aspect-ratio: 1;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 60px var(--shadow-color);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .album-art {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .album-art-placeholder {
            font-size: 100px;
            opacity: 0.5;
        }
        
        /* Metadata section */
        .metadata-section {
            text-align: center;
            width: 100%;
            padding: 0 10px;
            position: relative;
        }
        
        .now-playing-label {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-tertiary);
            margin-bottom: 10px;
        }
        
        .song-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 6px;
            color: var(--text-primary);
        }
        
        .artist-name {
            font-size: 16px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        
        .album-name {
            font-size: 14px;
            color: var(--text-quaternary);
        }
        
        .no-metadata {
            font-size: 16px;
            color: var(--text-tertiary);
            font-style: italic;
        }
        
        /* Like button */
        .like-btn {
            position: absolute;
            top: 0;
            right: 0;
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            border-radius: 20px;
            background: var(--card-bg);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            color: var(--text-secondary);
            backdrop-filter: blur(10px);
        }
        
        .like-btn:hover:not(.disabled) {
            background: var(--button-hover);
            border-color: var(--text-quaternary);
            transform: scale(1.05);
        }
        
        .like-btn.liked {
            background: rgba(255, 59, 92, 0.2);
            border-color: rgba(255, 59, 92, 0.6);
            color: #ff3b5c;
        }
        
        .like-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        /* Liked tracks section in settings */
        .liked-tracks-btn {
            width: 100%;
            padding: 15px;
            background: rgba(102, 126, 234, 0.2);
            border: 2px solid rgba(102, 126, 234, 0.5);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
        
        .liked-tracks-btn:hover {
            background: rgba(102, 126, 234, 0.3);
            transform: translateY(-2px);
        }
        
        .liked-tracks-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 60vh;
            overflow-y: auto;
        }
        
        .liked-track-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            border-radius: 10px;
            background: var(--input-bg);
            border: 2px solid var(--border-color);
            transition: all 0.3s;
        }
        
        .liked-track-item:hover {
            background: var(--card-bg);
            border-color: var(--border-color);
        }
        
        .liked-track-art {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            object-fit: cover;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        
        .liked-track-info {
            flex: 1;
            text-align: left;
            min-width: 0;
        }
        
        .liked-track-title {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 4px;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .liked-track-artist {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .liked-track-meta {
            font-size: 11px;
            color: var(--text-quaternary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .unlike-btn {
            padding: 8px 12px;
            background: rgba(255, 59, 92, 0.2);
            border: 2px solid rgba(255, 59, 92, 0.5);
            border-radius: 8px;
            color: #ff3b5c;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s;
            flex-shrink: 0;
        }
        
        .unlike-btn:hover {
            background: rgba(255, 59, 92, 0.3);
            transform: scale(1.1);
        }
        
        .clear-all-likes-btn {
            padding: 10px 20px;
            background: rgba(255, 107, 107, 0.2);
            border: 2px solid rgba(255, 107, 107, 0.5);
            border-radius: 8px;
            color: #ff6b6b;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s;
            margin-bottom: 15px;
        }
        
        .clear-all-likes-btn:hover {
            background: rgba(255, 107, 107, 0.3);
        }
        
        /* Controls */
        .controls {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
            width: 100%;
            position: relative;
        }
        
        .controls-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
        }
        
        /* Quality button (like button style) */
        .quality-btn {
            position: absolute;
            right: 0;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 20px;
            background: var(--card-bg);
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
            display: none;
            align-items: center;
            gap: 6px;
            color: var(--text-secondary);
            backdrop-filter: blur(10px);
            font-weight: 600;
        }
        
        .quality-btn:hover {
            background: var(--button-hover);
            border-color: var(--text-quaternary);
            transform: scale(1.05);
        }
        
        .quality-btn.visible {
            display: inline-flex;
        }
        
        .btn {
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .btn-play {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: var(--text-primary);
        }
        
        .btn-play:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 6px 30px rgba(102, 126, 234, 0.5);
        }
        
        .btn-pause {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: var(--text-primary);
        }
        
        .btn-pause:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 6px 30px rgba(245, 87, 108, 0.5);
        }
        
        .btn-stop {
            background: var(--card-bg);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
        }
        
        .btn-stop:hover:not(:disabled) {
            background: var(--button-hover);
        }
        
        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Status indicator */
        .status-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
        }
        
        .status-dot.playing {
            background: #4ade80;
            animation: pulse 2s infinite;
        }
        
        .status-dot.error {
            background: #ef4444;
        }
        
        .status-dot.loading {
            background: #fbbf24;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }
        
        /* Settings button */
        /* Settings content */
        .settings-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .setting-item {
            padding: 15px;
            background: var(--input-bg);
            border-radius: 10px;
            border: 1px solid var(--border-color);
        }
        
        .setting-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            display: block;
        }
        
        .setting-description {
            font-size: 12px;
            color: var(--text-tertiary);
            margin-top: 8px;
        }
        
        /* Theme toggle styles */
        .theme-toggle-container {
            margin-top: 10px;
        }
        
        .theme-toggle-btn {
            position: relative;
            display: flex;
            background: var(--input-bg);
            border: 2px solid var(--border-color);
            border-radius: 50px;
            padding: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            max-width: 280px;
        }
        
        .theme-toggle-btn:hover {
            border-color: var(--border-hover);
        }
        
        .theme-option {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 20px;
            border-radius: 50px;
            transition: all 0.3s ease;
            position: relative;
            z-index: 2;
            cursor: pointer;
        }
        
        .theme-icon {
            font-size: 18px;
        }
        
        .theme-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-tertiary);
            transition: color 0.3s ease;
        }
        
        .theme-option.active .theme-name {
            color: var(--text-primary);
        }
        
        .theme-slider {
            position: absolute;
            top: 4px;
            left: 4px;
            width: calc(50% - 4px);
            height: calc(100% - 8px);
            background: var(--card-hover);
            border-radius: 50px;
            transition: transform 0.3s ease;
            z-index: 1;
            box-shadow: 0 2px 8px var(--shadow-color);
        }
        
        [data-theme="light"] .theme-slider {
            transform: translateX(calc(100% + 4px));
        }
        
        /* Modal overlay */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--modal-overlay);
            backdrop-filter: blur(5px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        /* Modal content */
        .modal-content {
            background: var(--modal-bg);
            border-radius: 20px;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px var(--shadow-color);
            animation: modalSlideIn 0.3s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .modal-header {
            padding: 25px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-tertiary);
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
        }
        
        .modal-close:hover {
            background: var(--card-bg);
            color: var(--text-primary);
        }
        
        .modal-body {
            padding: 25px;
            overflow-x: hidden;
        }
        
        /* Search and filter controls */
        .search-controls {
            margin-bottom: 10px;
        }
        
        .search-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            background: var(--input-bg);
            color: var(--text-primary);
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .search-input:focus {
            outline: none;
            border-color: var(--text-quaternary);
            background: rgba(255, 255, 255, 0.08);
        }
        
        .search-input::placeholder {
            color: var(--text-quaternary);
        }
        
        /* Filter controls row */
        .filter-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .filter-container {
            position: relative;
            flex: 1;
        }
        
        .filter-btn {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            background: var(--input-bg);
            color: var(--text-primary);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        
        .filter-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .filter-btn-label {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .filter-dropdown {
            position: absolute;
            top: calc(100% + 5px);
            left: 0;
            right: 0;
            background: var(--dropdown-bg);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 8px 0;
            max-height: 0;
            overflow-y: auto;
            opacity: 0;
            z-index: 1000;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        .filter-dropdown.active {
            max-height: 300px;
            opacity: 1;
        }
        
        .filter-option {
            padding: 12px 20px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .filter-option:hover {
            background: var(--card-bg);
        }
        
        .filter-option.active {
            background: rgba(102, 126, 234, 0.3);
            color: var(--text-primary);
        }
        
        .filter-option-icon {
            font-size: 16px;
        }
        
        .genre-count {
            margin-left: auto;
            font-size: 12px;
            color: var(--text-quaternary);
        }
        
        /* Playlists section */
        .playlists-section {
            margin-bottom: 25px;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-tertiary);
        }
        
        .create-playlist-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            background: rgba(102, 126, 234, 0.2);
            color: #667eea;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .create-playlist-btn:hover {
            background: rgba(102, 126, 234, 0.3);
            transform: translateY(-1px);
        }
        
        .playlists-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .playlist-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 10px;
            background: var(--input-bg);
            cursor: grab;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        
        .playlist-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .playlist-item.drag-over {
            border-color: rgba(102, 126, 234, 0.6);
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }
        
        .playlist-item:hover {
            background: var(--card-bg);
            border-color: var(--border-color);
            transform: translateX(4px);
        }
        
        .playlist-item.dragging:hover {
            transform: none;
        }
        
        .playlist-icon {
            font-size: 24px;
            flex-shrink: 0;
        }
        
        .playlist-drag-handle {
            font-size: 16px;
            color: var(--text-quaternary);
            cursor: grab;
            user-select: none;
            flex-shrink: 0;
            padding: 0 4px;
            opacity: 0.6;
            transition: opacity 0.2s;
        }
        
        .playlist-item:hover .playlist-drag-handle {
            opacity: 1;
        }
        
        .playlist-item.dragging .playlist-drag-handle {
            cursor: grabbing;
        }
        
        .playlist-info {
            flex: 1;
            min-width: 0;
        }
        
        .playlist-name {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .playlist-count {
            font-size: 12px;
            color: var(--text-quaternary);
        }
        
        .playlist-menu-btn {
            background: none;
            border: none;
            color: var(--text-quaternary);
            font-size: 20px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 6px;
            transition: all 0.2s;
            position: relative;
        }
        
        .playlist-menu-btn:hover {
            background: var(--card-bg);
            color: var(--text-primary);
        }
        
        /* Station list */
        .station-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .station-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 10px;
            background: var(--input-bg);
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        
        .station-item:hover {
            background: var(--card-bg);
            border-color: var(--border-color);
            transform: translateX(4px);
        }
        
        .station-item.selected {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.15);
        }
        
        .station-icon {
            width: 48px;
            height: 48px;
            border-radius: 8px;
            object-fit: cover;
            background: var(--card-bg);
            flex-shrink: 0;
        }
        
        .station-info {
            flex: 1;
            min-width: 0;
        }
        
        .station-name {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .station-genres {
            font-size: 12px;
            color: var(--text-quaternary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .station-details {
            font-size: 11px;
            color: var(--text-quaternary);
            margin-top: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .station-menu-btn {
            background: none;
            border: none;
            color: var(--text-quaternary);
            font-size: 20px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 6px;
            transition: all 0.2s;
            position: relative;
        }
        
        .station-menu-btn:hover {
            background: var(--card-bg);
            color: var(--text-primary);
        }
        
        /* View toggle button */
        .view-toggle-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: rgba(102, 126, 234, 0.2);
            color: #667eea;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .view-toggle-btn:hover {
            background: rgba(102, 126, 234, 0.3);
            transform: translateY(-1px);
        }
        
        /* Grid view styles for stations */
        .station-list.grid-view {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
        }
        
        .station-list.grid-view .station-item {
            flex-direction: column;
            text-align: center;
            padding: 16px 12px;
        }
        
        .station-list.grid-view .station-item:hover {
            transform: translateY(-4px);
        }
        
        .station-list.grid-view .station-icon {
            width: 80px;
            height: 80px;
            border-radius: 12px;
        }
        
        .station-list.grid-view .station-info {
            width: 100%;
            text-align: center;
        }
        
        .station-list.grid-view .station-menu-btn {
            position: absolute;
            top: 8px;
            right: 8px;
        }
        
        /* Grid view styles for playlists */
        .playlists-list.grid-view {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
        }
        
        .playlists-list.grid-view .playlist-item {
            flex-direction: column;
            text-align: center;
            padding: 16px 12px;
            position: relative;
        }
        
        .playlists-list.grid-view .playlist-item:hover {
            transform: translateY(-4px);
        }
        
        .playlists-list.grid-view .playlist-icon {
            font-size: 48px;
            margin-bottom: 8px;
        }
        
        .playlists-list.grid-view .playlist-drag-handle {
            position: absolute;
            top: 8px;
            left: 8px;
        }
        
        .playlists-list.grid-view .playlist-info {
            width: 100%;
            text-align: center;
        }
        
        .playlists-list.grid-view .playlist-menu-btn {
            position: absolute;
            top: 8px;
            right: 8px;
        }
        
        /* Dropdown menu */
        .station-dropdown,
        .playlist-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: var(--dropdown-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            min-width: 180px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.2s;
        }
        
        .station-dropdown.active,
        .playlist-dropdown.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        .dropdown-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .dropdown-item:first-child {
            border-radius: 10px 10px 0 0;
        }
        
        .dropdown-item:last-child {
            border-radius: 0 0 10px 10px;
        }
        
        .dropdown-item:hover {
            background: var(--card-bg);
        }
        
        .dropdown-item.danger {
            color: #ef4444;
        }
        
        .dropdown-divider {
            height: 1px;
            background: var(--card-bg);
            margin: 4px 0;
        }
        
        .dropdown-submenu {
            position: relative;
        }
        
        .dropdown-submenu-content {
            position: absolute;
            right: 100%;
            top: 0;
            margin-right: 4px;
            background: var(--dropdown-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            min-width: 180px;
            max-width: 250px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transform: translateX(10px);
            transition: all 0.2s;
            max-height: 300px;
            overflow-y: auto;
            z-index: 101;
            white-space: normal;
            word-wrap: break-word;
        }
        
        /* Mobile responsive: position submenu below parent on narrow screens */
        @media (max-width: 600px) {
            .dropdown-submenu-content {
                position: fixed;
                left: 50%;
                top: auto;
                bottom: 20px;
                right: auto;
                margin: 0;
                transform: translateX(-50%) translateY(20px);
                min-width: calc(100vw - 40px);
                max-width: calc(100vw - 40px);
            }
            
            .dropdown-submenu:hover .dropdown-submenu-content,
            .dropdown-submenu.active .dropdown-submenu-content {
                transform: translateX(-50%) translateY(0);
            }
            
            /* Add backdrop for mobile submenu */
            .dropdown-submenu.active::before {
                content: '';
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 100;
                backdrop-filter: blur(2px);
            }
        }
        
        .dropdown-submenu:hover .dropdown-submenu-content,
        .dropdown-submenu.active .dropdown-submenu-content {
            opacity: 1;
            visibility: visible;
            transform: translateX(0);
        }
        
        /* Custom scrollbar for submenu */
        .dropdown-submenu-content::-webkit-scrollbar {
            width: 6px;
        }
        
        .dropdown-submenu-content::-webkit-scrollbar-track {
            background: var(--input-bg);
            border-radius: 10px;
        }
        
        .dropdown-submenu-content::-webkit-scrollbar-thumb {
            background: var(--button-hover);
            border-radius: 10px;
        }
        
        .dropdown-submenu-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        /* Empty state */
        .empty-state {
            padding: 40px 20px;
            text-align: center;
            color: var(--text-quaternary);
        }
        
        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        .empty-state-text {
            font-size: 14px;
            line-height: 1.6;
        }
        
        /* Form styles */
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .form-input,
        .form-textarea,
        .form-select {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            background: var(--input-bg);
            color: var(--text-primary);
            font-size: 14px;
            font-family: inherit;
            transition: all 0.2s;
        }
        
        .form-input:focus,
        .form-textarea:focus,
        .form-select:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255, 255, 255, 0.08);
        }
        
        .form-textarea {
            resize: vertical;
            min-height: 100px;
        }
        
        .form-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }
        
        .form-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .form-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 25px;
        }
        
        .form-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .form-btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: var(--text-primary);
        }
        
        .form-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .form-btn-secondary {
            background: var(--card-bg);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
        }
        
        .form-btn-secondary:hover {
            background: var(--card-hover);
        }
        
        /* Quality selector */
        /* Quality modal options */
        .quality-options-modal {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .quality-option-modal {
            padding: 16px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            background: var(--input-bg);
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .quality-option-modal:hover {
            border-color: var(--border-hover);
            background: var(--card-bg);
            transform: translateX(4px);
        }
        
        .quality-option-modal.selected {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.15);
        }
        
        .quality-option-modal.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        .quality-option-main {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 6px;
        }
        
        .quality-option-icon {
            font-size: 24px;
        }
        
        .quality-option-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .quality-option-desc {
            font-size: 13px;
            color: var(--text-tertiary);
            margin-left: 36px;
        }
        
        /* Back button */
        .back-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: var(--input-bg);
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 15px;
        }
        
        .back-btn:hover {
            background: var(--card-bg);
            color: var(--text-primary);
            transform: translateX(-2px);
        }
        
        /* Loading spinner */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: var(--text-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Responsive adjustments */
        @media (max-width: 600px) {
            .player-container {
                gap: 12px;
            }
            
            .artwork-container {
                max-width: 100%;
            }
            
            .song-title {
                font-size: 18px;
            }
            
            .artist-name {
                font-size: 15px;
            }
            
            .btn {
                padding: 12px 30px;
                font-size: 14px;
            }
            
            .modal-content {
                margin: 0 10px;
            }
            
            body {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <br>
    <div class="player-container">
        <!-- Currently playing station display -->
        <div id="stationDisplay" class="station-display" style="display: none;">
            <img id="stationDisplayIcon" class="station-display-icon" src="" alt="">
            <div class="station-display-info">
                <div id="stationDisplayName" class="station-display-name"></div>
                <div id="stationDisplayDetails" class="station-display-details"></div>
            </div>
        </div>
        
        <!-- Album artwork -->
        <div class="artwork-container" id="artworkContainer">
            <div class="album-art-placeholder">ðŸŽµ</div>
        </div>
        
        <!-- Metadata display -->
        <div class="metadata-section" id="metadataSection">
            <div class="now-playing-label">NOW PLAYING</div>
            <div class="no-metadata">Select a station to start streaming</div>
        </div>
        
        <!-- Player controls -->
        <div class="controls">
            <div class="controls-buttons">
                <button id="playPauseBtn" class="control-icon-btn btn-play" disabled>
                    <svg class="play-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M16.6582 9.28638C18.098 10.1862 18.8178 10.6361 19.0647 11.2122C19.2803 11.7152 19.2803 12.2847 19.0647 12.7878C18.8178 13.3638 18.098 13.8137 16.6582 14.7136L9.896 18.94C8.29805 19.9387 7.49907 20.4381 6.83973 20.385C6.26501 20.3388 5.73818 20.0469 5.3944 19.584C5 19.053 5 18.1108 5 16.2264V7.77357C5 5.88919 5 4.94701 5.3944 4.41598C5.73818 3.9531 6.26501 3.66111 6.83973 3.6149C7.49907 3.5619 8.29805 4.06126 9.896 5.05998L16.6582 9.28638Z" stroke-width="2" stroke-linejoin="round"/>
                    </svg>
                    <svg class="pause-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447C4.92893 2 7.28595 2 12 2C16.714 2 19.0711 2 20.5355 3.46447C22 4.92893 22 7.28595 22 12C22 16.714 22 19.0711 20.5355 20.5355C19.0711 22 16.714 22 12 22C7.28595 22 4.92893 22 3.46447 20.5355C2 19.0711 2 16.714 2 12Z" stroke-width="1.5"/>
                    </svg>
                </button>
            </div>
            <button id="qualityBtn" class="quality-btn">
                <span id="currentQuality">Standard</span>
                <span style="font-size: 10px;">â–¼</span>
            </button>
        </div>
        
        <!-- Status indicator -->
        <div class="status-indicator">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Not connected</span>
        </div>
        
        <!-- Navigation buttons (all in one row) -->
        <div style="display: flex; gap: 10px; width: 100%; justify-content: center;">
            <button id="settingsBtn" class="station-selector-btn icon-btn" title="Settings">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="12" cy="12" r="3" stroke-width="1.5"/>
                    <path opacity="0.5" d="M13.7654 2.15224C13.3978 2 12.9319 2 12 2C11.0681 2 10.6022 2 10.2346 2.15224C9.74457 2.35523 9.35522 2.74458 9.15223 3.23463C9.05957 3.45834 9.0233 3.7185 9.00911 4.09799C8.98826 4.65568 8.70226 5.17189 8.21894 5.45093C7.73564 5.72996 7.14559 5.71954 6.65219 5.45876C6.31645 5.2813 6.07301 5.18262 5.83294 5.15102C5.30704 5.08178 4.77518 5.22429 4.35436 5.5472C4.03874 5.78938 3.80577 6.1929 3.33983 6.99993C2.87389 7.80697 2.64092 8.21048 2.58899 8.60491C2.51976 9.1308 2.66227 9.66266 2.98518 10.0835C3.13256 10.2756 3.3397 10.437 3.66119 10.639C4.1338 10.936 4.43789 11.4419 4.43786 12C4.43783 12.5581 4.13375 13.0639 3.66118 13.3608C3.33965 13.5629 3.13248 13.7244 2.98508 13.9165C2.66217 14.3373 2.51966 14.8691 2.5889 15.395C2.64082 15.7894 2.87379 16.193 3.33973 17C3.80568 17.807 4.03865 18.2106 4.35426 18.4527C4.77508 18.7756 5.30694 18.9181 5.83284 18.8489C6.07289 18.8173 6.31632 18.7186 6.65204 18.5412C7.14547 18.2804 7.73556 18.27 8.2189 18.549C8.70224 18.8281 8.98826 19.3443 9.00911 19.9021C9.02331 20.2815 9.05957 20.5417 9.15223 20.7654C9.35522 21.2554 9.74457 21.6448 10.2346 21.8478C10.6022 22 11.0681 22 12 22C12.9319 22 13.3978 22 13.7654 21.8478C14.2554 21.6448 14.6448 21.2554 14.8477 20.7654C14.9404 20.5417 14.9767 20.2815 14.9909 19.902C15.0117 19.3443 15.2977 18.8281 15.781 18.549C16.2643 18.2699 16.8544 18.2804 17.3479 18.5412C17.6836 18.7186 17.927 18.8172 18.167 18.8488C18.6929 18.9181 19.2248 18.7756 19.6456 18.4527C19.9612 18.2105 20.1942 17.807 20.6601 16.9999C21.1261 16.1929 21.3591 15.7894 21.411 15.395C21.4802 14.8691 21.3377 14.3372 21.0148 13.9164C20.8674 13.7243 20.6602 13.5628 20.3387 13.3608C19.8662 13.0639 19.5621 12.558 19.5621 11.9999C19.5621 11.4418 19.8662 10.9361 20.3387 10.6392C20.6603 10.4371 20.8675 10.2757 21.0149 10.0835C21.3378 9.66273 21.4803 9.13087 21.4111 8.60497C21.3592 8.21055 21.1262 7.80703 20.6602 7C20.1943 6.19297 19.9613 5.78945 19.6457 5.54727C19.2249 5.22436 18.693 5.08185 18.1671 5.15109C17.9271 5.18269 17.6837 5.28136 17.3479 5.4588C16.8545 5.71959 16.2644 5.73002 15.7811 5.45096C15.2977 5.17191 15.0117 4.65566 14.9909 4.09794C14.9767 3.71848 14.9404 3.45833 14.8477 3.23463C14.6448 2.74458 14.2554 2.35523 13.7654 2.15224Z" stroke-width="1.5"/>
                </svg>
            </button>
            <button id="playlistsBtn" class="station-selector-btn icon-btn" title="Playlists">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M9 6.75C8.58579 6.75 8.25 7.08579 8.25 7.5C8.25 7.91421 8.58579 8.25 9 8.25V6.75ZM19 8.25C19.4142 8.25 19.75 7.91421 19.75 7.5C19.75 7.08579 19.4142 6.75 19 6.75V8.25ZM5 6.75C4.58579 6.75 4.25 7.08579 4.25 7.5C4.25 7.91421 4.58579 8.25 5 8.25V6.75ZM6 8.25C6.41421 8.25 6.75 7.91421 6.75 7.5C6.75 7.08579 6.41421 6.75 6 6.75V8.25ZM5 11.75C4.58579 11.75 4.25 12.0858 4.25 12.5C4.25 12.9142 4.58579 13.25 5 13.25V11.75ZM6 13.25C6.41421 13.25 6.75 12.9142 6.75 12.5C6.75 12.0858 6.41421 11.75 6 11.75V13.25ZM5 16.75C4.58579 16.75 4.25 17.0858 4.25 17.5C4.25 17.9142 4.58579 18.25 5 18.25V16.75ZM6 18.25C6.41421 18.25 6.75 17.9142 6.75 17.5C6.75 17.0858 6.41421 16.75 6 16.75V18.25ZM9 11.75C8.58579 11.75 8.25 12.0858 8.25 12.5C8.25 12.9142 8.58579 13.25 9 13.25V11.75ZM19 13.25C19.4142 13.25 19.75 12.9142 19.75 12.5C19.75 12.0858 19.4142 11.75 19 11.75V13.25ZM9 16.75C8.58579 16.75 8.25 17.0858 8.25 17.5C8.25 17.9142 8.58579 18.25 9 18.25V16.75ZM19 18.25C19.4142 18.25 19.75 17.9142 19.75 17.5C19.75 17.0858 19.4142 16.75 19 16.75V18.25ZM9 8.25H19V6.75H9V8.25ZM5 8.25H6V6.75H5V8.25ZM5 13.25H6V11.75H5V13.25ZM5 18.25H6V16.75H5V18.25ZM9 13.25H19V11.75H9V13.25ZM9 18.25H19V16.75H9V18.25Z"/>
                </svg>
            </button>
            <button id="browseStationsBtn" class="station-selector-btn icon-btn" title="Browse">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M15.6786 1.68083C15.855 2.05562 15.6941 2.50242 15.3193 2.67879L9.85515 5.25018C9.88453 5.25018 9.91401 5.25018 9.94358 5.25018H14.0564C15.8942 5.25016 17.3498 5.25015 18.489 5.40331C19.6614 5.56094 20.6104 5.89306 21.3588 6.64142C22.1071 7.38978 22.4392 8.33873 22.5969 9.51115C22.75 10.6504 22.75 12.106 22.75 13.9438V14.0566C22.75 15.8944 22.75 17.35 22.5969 18.4892C22.4392 19.6616 22.1071 20.6106 21.3588 21.3589C20.6104 22.1073 19.6614 22.4394 18.489 22.597C17.3498 22.7502 15.8942 22.7502 14.0564 22.7502H9.94359C8.10583 22.7502 6.65019 22.7502 5.51098 22.597C4.33856 22.4394 3.38961 22.1073 2.64124 21.3589C1.89288 20.6106 1.56076 19.6616 1.40314 18.4892C1.24997 17.35 1.24998 15.8944 1.25 14.0566V13.9438C1.24998 12.106 1.24997 10.6504 1.40314 9.51115C1.56076 8.33873 1.89288 7.38978 2.64124 6.64142C3.38961 5.89306 4.33856 5.56094 5.51098 5.40331C5.71495 5.37589 5.92907 5.35337 6.15372 5.33489C6.16257 5.33029 6.17155 5.32585 6.18065 5.32156L14.6807 1.32156C15.0554 1.14519 15.5022 1.30604 15.6786 1.68083ZM5.71085 6.88994C4.70476 7.0252 4.12511 7.27887 3.7019 7.70208C3.27869 8.12529 3.02502 8.70494 2.88976 9.71103C2.75159 10.7387 2.75 12.0934 2.75 14.0002C2.75 15.907 2.75159 17.2617 2.88976 18.2893C3.02502 19.2954 3.27869 19.8751 3.7019 20.2983C4.12511 20.7215 4.70476 20.9752 5.71085 21.1104C6.73851 21.2486 8.09318 21.2502 10 21.2502H14C15.9068 21.2502 17.2615 21.2486 18.2892 21.1104C19.2952 20.9752 19.8749 20.7215 20.2981 20.2983C20.7213 19.8751 20.975 19.2954 21.1102 18.2893C21.2484 17.2617 21.25 15.907 21.25 14.0002C21.25 12.0934 21.2484 10.7387 21.1102 9.71103C20.975 8.70494 20.7213 8.12529 20.2981 7.70208C19.8749 7.27887 19.2952 7.0252 18.2892 6.88994C17.2615 6.75177 15.9068 6.75018 14 6.75018H10C8.09318 6.75018 6.73851 6.75177 5.71085 6.88994ZM8 11.7502C6.75736 11.7502 5.75 12.7575 5.75 14.0002C5.75 15.2428 6.75736 16.2502 8 16.2502C9.24264 16.2502 10.25 15.2428 10.25 14.0002C10.25 12.7575 9.24264 11.7502 8 11.7502ZM4.25 14.0002C4.25 11.9291 5.92893 10.2502 8 10.2502C10.0711 10.2502 11.75 11.9291 11.75 14.0002C11.75 16.0712 10.0711 17.7502 8 17.7502C5.92893 17.7502 4.25 16.0712 4.25 14.0002ZM12.75 11.0002C12.75 10.586 13.0858 10.2502 13.5 10.2502H19C19.4142 10.2502 19.75 10.586 19.75 11.0002C19.75 11.4144 19.4142 11.7502 19 11.7502H13.5C13.0858 11.7502 12.75 11.4144 12.75 11.0002ZM12.75 14.0002C12.75 13.586 13.0858 13.2502 13.5 13.2502H19C19.4142 13.2502 19.75 13.586 19.75 14.0002C19.75 14.4144 19.4142 14.7502 19 14.7502H13.5C13.0858 14.7502 12.75 14.4144 12.75 14.0002ZM12.75 17.0002C12.75 16.586 13.0858 16.2502 13.5 16.2502H19C19.4142 16.2502 19.75 16.586 19.75 17.0002C19.75 17.4144 19.4142 17.7502 19 17.7502H13.5C13.0858 17.7502 12.75 17.4144 12.75 17.0002Z"/>
                </svg>
            </button>
            <button id="mostPlayedBtn" class="station-selector-btn icon-btn" title="Most Played">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M11.993 5.09691C11.0387 4.25883 9.78328 3.75 8.40796 3.75C5.42122 3.75 3 6.1497 3 9.10988C3 10.473 3.50639 11.7242 4.35199 12.67L12 20.25L19.4216 12.8944L19.641 12.6631C20.4866 11.7172 21 10.473 21 9.10988C21 6.1497 18.5788 3.75 15.592 3.75C14.2167 3.75 12.9613 4.25883 12.007 5.09692L12 5.08998L11.993 5.09691ZM12 7.09938L12.0549 7.14755L12.9079 6.30208L12.9968 6.22399C13.6868 5.61806 14.5932 5.25 15.592 5.25C17.763 5.25 19.5 6.99073 19.5 9.10988C19.5 10.0813 19.1385 10.9674 18.5363 11.6481L18.3492 11.8453L12 18.1381L5.44274 11.6391C4.85393 10.9658 4.5 10.0809 4.5 9.10988C4.5 6.99073 6.23699 5.25 8.40796 5.25C9.40675 5.25 10.3132 5.61806 11.0032 6.22398L11.0921 6.30203L11.9452 7.14752L12 7.09938Z"/>
                </svg>
            </button>
            <button id="recentStationsBtn" class="station-selector-btn icon-btn" title="Recent">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <rect width="24" height="24" fill="none"/>
                    <path d="M9.682,18.75a.75.75,0,0,1,.75-.75,8.25,8.25,0,1,0-6.189-2.795V12.568a.75.75,0,0,1,1.5,0v4.243a.75.75,0,0,1-.751.75H.75a.75.75,0,0,1,0-1.5H3a9.75,9.75,0,1,1,7.433,3.44A.75.75,0,0,1,9.682,18.75Zm2.875-4.814L9.9,11.281a.754.754,0,0,1-.22-.531V5.55a.75.75,0,1,1,1.5,0v4.889l2.436,2.436a.75.75,0,1,1-1.061,1.06Z" transform="translate(1.568 2.25)"/>
                </svg>
            </button>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Settings</h2>
                <button class="modal-close" id="closeSettingsModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-content">
                    <div class="setting-item">
                        <label class="setting-label">CORS Proxy</label>
                        <div class="form-checkbox">
                            <input type="checkbox" id="globalCorsProxy" checked>
                            <label for="globalCorsProxy" style="cursor: pointer;">Use CORS Proxy</label>
                        </div>
                        <div class="setting-description">
                            Enable this if streams fail to load. Uses a proxy to bypass CORS restrictions.
                        </div>
                    </div>
                    
                    <div class="setting-item">
                        <label class="setting-label">Album Artwork</label>
                        <div class="form-checkbox">
                            <input type="checkbox" id="useItunesApi" checked>
                            <label for="useItunesApi" style="cursor: pointer;">Use iTunes API for Artwork</label>
                        </div>
                        <div class="setting-description">
                            Automatically fetch album artwork from iTunes when available.
                        </div>
                    </div>
                    
                    <div class="setting-item">
                        <label class="setting-label">Theme</label>
                        <div class="theme-toggle-container">
                            <button class="theme-toggle-btn" id="themeToggle">
                                <span class="theme-option" data-theme="dark">
                                    <span class="theme-icon">ðŸŒ™</span>
                                    <span class="theme-name">Dark</span>
                                </span>
                                <span class="theme-option" data-theme="light">
                                    <span class="theme-icon">â˜€ï¸</span>
                                    <span class="theme-name">Light</span>
                                </span>
                                <span class="theme-slider"></span>
                            </button>
                        </div>
                        <div class="setting-description">
                            Switch between dark and light theme.
                        </div>
                    </div>
                    
                    <!-- Liked Tracks Button -->
                    <button class="liked-tracks-btn" id="viewLikedTracksBtn">
                        â™¥ View Liked Tracks
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Quality Modal -->
    <div id="qualityModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 350px;">
            <div class="modal-header">
                <h2 class="modal-title">Stream Quality</h2>
                <button class="modal-close" id="closeQualityModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="quality-options-modal">
                    <div class="quality-option-modal" data-quality="low">
                        <div class="quality-option-main">
                            <span class="quality-option-icon">ðŸ”‰</span>
                            <span class="quality-option-name">Low Quality</span>
                        </div>
                        <div class="quality-option-desc">Best for slower connections</div>
                    </div>
                    <div class="quality-option-modal selected" data-quality="standard">
                        <div class="quality-option-main">
                            <span class="quality-option-icon">ðŸ”Š</span>
                            <span class="quality-option-name">Standard Quality</span>
                        </div>
                        <div class="quality-option-desc">Balanced quality and bandwidth</div>
                    </div>
                    <div class="quality-option-modal" data-quality="high">
                        <div class="quality-option-main">
                            <span class="quality-option-icon">ðŸ“»</span>
                            <span class="quality-option-name">High Quality</span>
                        </div>
                        <div class="quality-option-desc">Best audio quality (requires fast connection)</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Liked Tracks Modal -->
    <div id="likedTracksModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Liked Tracks</h2>
                <button class="modal-close" id="closeLikedTracksModal">&times;</button>
            </div>
            <div class="modal-body">
                <button class="clear-all-likes-btn" id="clearAllLikesBtn" style="display: none;">
                    Clear All Liked Tracks
                </button>
                <div class="liked-tracks-list" id="likedTracksList">
                    <div class="empty-state">
                        <div class="empty-state-icon">â™¡</div>
                        <div class="empty-state-text">No liked tracks yet. Like a track while listening to save it here!</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Playlists Modal -->
    <div id="playlistsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">My Playlists</h2>
                <button class="modal-close" id="closePlaylistsModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Playlists Section -->
                <div class="playlists-section" id="playlistsSection">
                    <div class="section-header">
                        <h3 class="section-title">Playlists</h3>
                        <div style="display: flex; gap: 10px;">
                            <button class="view-toggle-btn" id="playlistViewToggle">
                                <span id="playlistViewIcon">âŠž</span>
                                <span id="playlistViewText">Grid</span>
                            </button>
                            <button class="create-playlist-btn" id="createPlaylistBtn">
                                + New Playlist
                            </button>
                        </div>
                    </div>
                    <div class="playlists-list" id="playlistsList"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Browse Stations Modal -->
    <div id="browseStationsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Browse Stations</h2>
                <button class="modal-close" id="closeBrowseStationsModal">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Search -->
                <div class="search-controls">
                    <input 
                        type="text" 
                        id="stationSearch" 
                        class="search-input" 
                        placeholder="Search stations..."
                    >
                </div>
                
                <!-- Filter Controls -->
                <div class="filter-controls">
                    <div class="filter-container">
                        <button class="filter-btn" id="genreBtn">
                            <span class="filter-btn-label" id="genreLabel">All Genres</span>
                            <span>â–¼</span>
                        </button>
                        <div class="filter-dropdown" id="genreDropdown">
                            <div class="filter-option active" data-genre="">
                                <span class="filter-option-icon">ðŸŽµ</span>
                                <span>All Genres</span>
                            </div>
                        </div>
                    </div>
                    <div class="filter-container">
                        <button class="filter-btn" id="sortBtn">
                            <span class="filter-btn-label" id="sortLabel">Name (A-Z)</span>
                            <span>â–¼</span>
                        </button>
                        <div class="filter-dropdown" id="sortDropdown">
                            <div class="filter-option active" data-sort="name-asc">
                                <span class="filter-option-icon">ðŸ”¤</span>
                                <span>Name (A-Z)</span>
                            </div>
                            <div class="filter-option" data-sort="name-desc">
                                <span class="filter-option-icon">ðŸ”¤</span>
                                <span>Name (Z-A)</span>
                            </div>
                            <div class="filter-option" data-sort="most-played">
                                <span class="filter-option-icon">ðŸ”¥</span>
                                <span>Most Played</span>
                            </div>
                            <div class="filter-option" data-sort="recent">
                                <span class="filter-option-icon">ðŸ•</span>
                                <span>Recently Played</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Stations Section -->
                <div class="section-header">
                    <h3 class="section-title">All Stations</h3>
                    <div style="display: flex; gap: 10px;">
                        <button class="view-toggle-btn" id="stationViewToggle">
                            <span id="stationViewIcon">âŠž</span>
                            <span id="stationViewText">Grid</span>
                        </button>
                        <button class="create-playlist-btn" id="addStationBtn">
                            + Add Station
                        </button>
                    </div>
                </div>
                <div class="station-list" id="stationList"></div>
            </div>
        </div>
    </div>
    
    <!-- Playlist Detail Modal -->
    <div id="playlistModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="playlistModalTitle">Playlist</h2>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button class="view-toggle-btn" id="playlistStationViewToggle">
                        <span id="playlistStationViewIcon">âŠž</span>
                        <span id="playlistStationViewText">Grid</span>
                    </button>
                    <button class="modal-close" id="closePlaylistModal">&times;</button>
                </div>
            </div>
            <div class="modal-body">
                <button class="back-btn" id="backToStations">
                    â† Back to Stations
                </button>
                <div class="station-list" id="playlistStationList"></div>
            </div>
        </div>
    </div>
    
    <!-- Create/Edit Playlist Modal -->
    <div id="playlistFormModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="playlistFormTitle">Create Playlist</h2>
                <button class="modal-close" id="closePlaylistFormModal">&times;</button>
            </div>
            <div class="modal-body">
                <form id="playlistForm">
                    <div class="form-group">
                        <label class="form-label" for="playlistName">Playlist Name</label>
                        <input 
                            type="text" 
                            id="playlistName" 
                            class="form-input" 
                            placeholder="My Favorite Stations"
                            required
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="playlistDescription">Description (Optional)</label>
                        <textarea 
                            id="playlistDescription" 
                            class="form-textarea" 
                            placeholder="A collection of my favorite stations..."
                        ></textarea>
                    </div>
                    <div class="form-actions">
                        <button type="button" class="form-btn form-btn-secondary" id="cancelPlaylistForm">
                            Cancel
                        </button>
                        <button type="submit" class="form-btn form-btn-primary">
                            Save Playlist
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Station Form Modal (for add/edit station) -->
    <div id="stationFormModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="stationFormTitle">Add Station</h2>
                <button class="modal-close" id="closeStationFormModal">&times;</button>
            </div>
            <div class="modal-body">
                <form id="stationForm">
                    <div class="form-group">
                        <label class="form-label" for="stationName">Station Name</label>
                        <input 
                            type="text" 
                            id="stationFormName" 
                            class="form-input" 
                            placeholder="Station Name"
                            required
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationUrl">Stream URL</label>
                        <input 
                            type="url" 
                            id="stationFormUrl" 
                            class="form-input" 
                            placeholder="https://stream.example.com/radio"
                            required
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationUrlLow">Low Quality URL (Optional)</label>
                        <input 
                            type="url" 
                            id="stationFormUrlLow" 
                            class="form-input" 
                            placeholder="https://stream.example.com/radio-low"
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationUrlHigh">High Quality URL (Optional)</label>
                        <input 
                            type="url" 
                            id="stationFormUrlHigh" 
                            class="form-input" 
                            placeholder="https://stream.example.com/radio-high"
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationGenres">Genres</label>
                        <input 
                            type="text" 
                            id="stationFormGenres" 
                            class="form-input" 
                            placeholder="Rock, Pop, Jazz"
                        >
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="stationIconUrl">Icon URL (Optional)</label>
                        <input 
                            type="url" 
                            id="stationFormIconUrl" 
                            class="form-input" 
                            placeholder="https://example.com/icon.png"
                        >
                    </div>
                    <div class="form-actions">
                        <button type="button" class="form-btn form-btn-secondary" id="cancelStationForm">
                            Cancel
                        </button>
                        <button type="submit" class="form-btn form-btn-primary">
                            Save Station
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <script>
        // ======================
        // GLOBAL VARIABLES
        // ======================
        
        let supabase;
        let player = null;
        let hlsPlayer = null;
        let audioElement = null;
        let isPlaying = false;
        let isPaused = false; // Track pause state separately
        let currentStation = null;
        let stations = [];
        let filteredStations = [];
        let playlists = [];
        let currentPlaylist = null;
        
        // Current track info for liked tracks feature
        let currentTrack = {
            title: null,
            artist: null,
            album: null,
            artworkUrl: null
        };
        let playlistStations = [];
        let selectedQuality = 'standard';
        let editingStationId = null;
        let editingPlaylistId = null;
        let currentSortMethod = 'name-asc'; // Default sort method
        let currentGenreFilter = ''; // Empty string means all genres
        
        // View mode state
        let stationViewMode = 'list'; // 'list' or 'grid'
        let playlistViewMode = 'list'; // 'list' or 'grid'
        let playlistStationViewMode = 'list'; // 'list' or 'grid' for playlist detail view
        
        // DOM Elements
        const playlistsBtn = document.getElementById('playlistsBtn');
        const browseStationsBtn = document.getElementById('browseStationsBtn');
        const stationSelectorButtons = document.getElementById('stationSelectorButtons');
        const stationDisplay = document.getElementById('stationDisplay');
        const stationDisplayIcon = document.getElementById('stationDisplayIcon');
        const stationDisplayName = document.getElementById('stationDisplayName');
        const playlistsModal = document.getElementById('playlistsModal');
        const closePlaylistsModal = document.getElementById('closePlaylistsModal');
        const browseStationsModal = document.getElementById('browseStationsModal');
        const closeBrowseStationsModal = document.getElementById('closeBrowseStationsModal');
        const settingsModal = document.getElementById('settingsModal');
        const settingsBtn = document.getElementById('settingsBtn');
        const closeSettingsModal = document.getElementById('closeSettingsModal');
        const stationList = document.getElementById('stationList');
        const stationSearch = document.getElementById('stationSearch');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const playIcon = playPauseBtn.querySelector('.play-icon');
        const pauseIcon = playPauseBtn.querySelector('.pause-icon');
        const artworkContainer = document.getElementById('artworkContainer');
        const metadataDiv = document.getElementById('metadataSection');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        
        // Playlist elements
        const playlistsSection = document.getElementById('playlistsSection');
        const playlistsList = document.getElementById('playlistsList');
        const createPlaylistBtn = document.getElementById('createPlaylistBtn');
        const playlistModal = document.getElementById('playlistModal');
        const closePlaylistModal = document.getElementById('closePlaylistModal');
        const playlistModalTitle = document.getElementById('playlistModalTitle');
        const backToStations = document.getElementById('backToStations');
        const playlistStationList = document.getElementById('playlistStationList');
        
        // Sort and genre filter elements
        const genreBtn = document.getElementById('genreBtn');
        const genreDropdown = document.getElementById('genreDropdown');
        const genreLabel = document.getElementById('genreLabel');
        const sortBtn = document.getElementById('sortBtn');
        const sortDropdown = document.getElementById('sortDropdown');
        const sortLabel = document.getElementById('sortLabel');
        
        // View toggle elements
        const stationViewToggle = document.getElementById('stationViewToggle');
        const stationViewIcon = document.getElementById('stationViewIcon');
        const stationViewText = document.getElementById('stationViewText');
        const playlistViewToggle = document.getElementById('playlistViewToggle');
        const playlistViewIcon = document.getElementById('playlistViewIcon');
        const playlistViewText = document.getElementById('playlistViewText');
        const playlistStationViewToggle = document.getElementById('playlistStationViewToggle');
        const playlistStationViewIcon = document.getElementById('playlistStationViewIcon');
        const playlistStationViewText = document.getElementById('playlistStationViewText');
        
        // Playlist form elements
        const playlistFormModal = document.getElementById('playlistFormModal');
        const closePlaylistFormModal = document.getElementById('closePlaylistFormModal');
        const playlistFormTitle = document.getElementById('playlistFormTitle');
        const playlistForm = document.getElementById('playlistForm');
        const playlistName = document.getElementById('playlistName');
        const playlistDescription = document.getElementById('playlistDescription');
        const cancelPlaylistForm = document.getElementById('cancelPlaylistForm');
        
        // Liked tracks elements
        const viewLikedTracksBtn = document.getElementById('viewLikedTracksBtn');
        const likedTracksModal = document.getElementById('likedTracksModal');
        const closeLikedTracksModal = document.getElementById('closeLikedTracksModal');
        const likedTracksList = document.getElementById('likedTracksList');
        const clearAllLikesBtn = document.getElementById('clearAllLikesBtn');
        
        // ======================
        // LIKED TRACKS FUNCTIONS
        // ======================
        
        // Load liked tracks from localStorage
        function loadLikedTracks() {
            const stored = localStorage.getItem('likedTracks');
            return stored ? JSON.parse(stored) : [];
        }
        
        // Save liked tracks to localStorage
        function saveLikedTracks(tracks) {
            localStorage.setItem('likedTracks', JSON.stringify(tracks));
        }
        
        // Check if current track is liked
        function isCurrentTrackLiked() {
            if (!currentTrack.title || !currentTrack.artist) return false;
            const likedTracks = loadLikedTracks();
            return likedTracks.some(track => 
                track.title === currentTrack.title && 
                track.artist === currentTrack.artist
            );
        }
        
        // Toggle like for current track
        function toggleLikeTrack() {
            if (!currentTrack.title || !currentTrack.artist) return;
            
            const likedTracks = loadLikedTracks();
            const trackIndex = likedTracks.findIndex(track => 
                track.title === currentTrack.title && 
                track.artist === currentTrack.artist
            );
            
            if (trackIndex >= 0) {
                // Unlike
                likedTracks.splice(trackIndex, 1);
            } else {
                // Like
                const newLikedTrack = {
                    title: currentTrack.title,
                    artist: currentTrack.artist,
                    album: currentTrack.album || '',
                    artworkUrl: currentTrack.artworkUrl || '',
                    station: currentStation ? currentStation.name : 'Unknown Station',
                    timestamp: new Date().toISOString()
                };
                likedTracks.unshift(newLikedTrack);
            }
            
            saveLikedTracks(likedTracks);
            updateLikeButton();
        }
        
        // Update like button state
        function updateLikeButton() {
            const likeBtn = document.getElementById('likeBtn');
            if (!likeBtn) return;
            
            if (!currentTrack.title || !currentTrack.artist) {
                likeBtn.classList.add('disabled');
                likeBtn.innerHTML = 'â™¡';
                return;
            }
            
            likeBtn.classList.remove('disabled');
            
            if (isCurrentTrackLiked()) {
                likeBtn.classList.add('liked');
                likeBtn.innerHTML = 'â™¥';
            } else {
                likeBtn.classList.remove('liked');
                likeBtn.innerHTML = 'â™¡';
            }
        }
        
        // Display liked tracks in modal
        function displayLikedTracks() {
            const likedTracks = loadLikedTracks();
            
            if (likedTracks.length === 0) {
                likedTracksList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">â™¡</div>
                        <div class="empty-state-text">No liked tracks yet. Like a track while listening to save it here!</div>
                    </div>
                `;
                clearAllLikesBtn.style.display = 'none';
            } else {
                clearAllLikesBtn.style.display = 'block';
                likedTracksList.innerHTML = likedTracks.map((track, index) => {
                    const date = new Date(track.timestamp);
                    const timeAgo = getTimeAgo(date);
                    
                    return `
                        <div class="liked-track-item">
                            ${track.artworkUrl ? 
                                `<img class="liked-track-art" src="${track.artworkUrl}" alt="${escapeHtml(track.title)}">` :
                                `<div class="liked-track-art">â™ª</div>`
                            }
                            <div class="liked-track-info">
                                <div class="liked-track-title">${escapeHtml(track.title)}</div>
                                <div class="liked-track-artist">${escapeHtml(track.artist)}</div>
                                <div class="liked-track-meta">
                                    ${escapeHtml(track.station)} â€¢ ${timeAgo}
                                </div>
                            </div>
                            <button class="unlike-btn" onclick="unlikeTrack(${index})">Ã—</button>
                        </div>
                    `;
                }).join('');
            }
        }
        
        // Unlike a track by index
        function unlikeTrack(index) {
            const likedTracks = loadLikedTracks();
            likedTracks.splice(index, 1);
            saveLikedTracks(likedTracks);
            displayLikedTracks();
            updateLikeButton();
        }
        
        // Clear all liked tracks
        function clearAllLikedTracks() {
            if (confirm('Are you sure you want to clear all liked tracks? This cannot be undone.')) {
                saveLikedTracks([]);
                displayLikedTracks();
                updateLikeButton();
            }
        }
        
        // Helper function to get time ago string
        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            const intervals = {
                year: 31536000,
                month: 2592000,
                week: 604800,
                day: 86400,
                hour: 3600,
                minute: 60
            };
            
            for (const [unit, secondsInUnit] of Object.entries(intervals)) {
                const interval = Math.floor(seconds / secondsInUnit);
                if (interval >= 1) {
                    return `${interval} ${unit}${interval === 1 ? '' : 's'} ago`;
                }
            }
            
            return 'Just now';
        }

        
        // Station form elements
        const stationFormModal = document.getElementById('stationFormModal');
        const closeStationFormModal = document.getElementById('closeStationFormModal');
        const stationFormTitle = document.getElementById('stationFormTitle');
        const stationForm = document.getElementById('stationForm');
        const cancelStationForm = document.getElementById('cancelStationForm');
        
        // ======================
        // SUPABASE INITIALIZATION
        // ======================
        
        // Initialize Supabase - Replace with your credentials
        const SUPABASE_URL = 'https://zwrunupvlkhnwbylzizj.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inp3cnVudXB2bGtobndieWx6aXpqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjExMTIxNzEsImV4cCI6MjA3NjY4ODE3MX0.WBTLcTNWgGZ-I6o_Dd7ObfS2avmJc_iiIEpDp8-VuQ4';
          
        try {
            supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        } catch (error) {
            console.error('Failed to initialize Supabase:', error);
            updateStatus('Error: Failed to connect to database', 'error');
        }
        
        // ======================
        // DATABASE FUNCTIONS
        // ======================
        
        // ======================
        // STATION HISTORY TRACKING
        // ======================
        
        // Generate a simple anonymous user ID for tracking
        function getOrCreateUserId() {
            let userId = localStorage.getItem('radio_user_id');
            if (!userId) {
                userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('radio_user_id', userId);
            }
            return userId;
        }
        
        // Track station click in Supabase
        async function trackStationClick(stationId) {
            try {
                const userId = getOrCreateUserId();
                const { error} = await supabase
                    .from('station_history')
                    .insert({
                        station_id: stationId,
                        user_id: userId,
                        clicked_at: new Date().toISOString()
                    });
                
                if (error) {
                    console.error('Error tracking station click:', error);
                    trackStationClickLocal(stationId);
                } else {
                    console.log('Station click tracked successfully');
                    trackStationClickLocal(stationId);
                }
            } catch (error) {
                console.error('Error tracking station click:', error);
                trackStationClickLocal(stationId);
            }
        }
        
        // Track station click in local storage (backup method)
        function trackStationClickLocal(stationId) {
            try {
                let history = JSON.parse(localStorage.getItem('station_history') || '[]');
                history.push({
                    station_id: stationId,
                    clicked_at: new Date().toISOString()
                });
                if (history.length > 500) {
                    history = history.slice(-500);
                }
                localStorage.setItem('station_history', JSON.stringify(history));
            } catch (error) {
                console.error('Error tracking station click locally:', error);
            }
        }
        
        // Get most recent stations
        async function getMostRecentStations(limit = 10) {
            try {
                const userId = getOrCreateUserId();
                
                const { data, error } = await supabase
                    .from('station_history')
                    .select('station_id, clicked_at')
                    .eq('user_id', userId)
                    .order('clicked_at', { ascending: false })
                    .limit(limit * 3);
                
                if (error) throw error;
                
                const uniqueStationIds = [];
                const seenIds = new Set();
                
                for (const record of data) {
                    if (!seenIds.has(record.station_id)) {
                        seenIds.add(record.station_id);
                        uniqueStationIds.push(record.station_id);
                        if (uniqueStationIds.length >= limit) break;
                    }
                }
                
                return stations.filter(s => uniqueStationIds.includes(s.id))
                    .sort((a, b) => uniqueStationIds.indexOf(a.id) - uniqueStationIds.indexOf(b.id));
                
            } catch (error) {
                console.error('Error getting recent stations from database:', error);
                return getMostRecentStationsLocal(limit);
            }
        }
        
        // Get most recent stations from local storage (fallback)
        function getMostRecentStationsLocal(limit = 10) {
            try {
                const history = JSON.parse(localStorage.getItem('station_history') || '[]');
                
                const uniqueStationIds = [];
                const seenIds = new Set();
                
                for (let i = history.length - 1; i >= 0; i--) {
                    const stationId = history[i].station_id;
                    if (!seenIds.has(stationId)) {
                        seenIds.add(stationId);
                        uniqueStationIds.push(stationId);
                        if (uniqueStationIds.length >= limit) break;
                    }
                }
                
                return stations.filter(s => uniqueStationIds.includes(s.id))
                    .sort((a, b) => uniqueStationIds.indexOf(a.id) - uniqueStationIds.indexOf(b.id));
                
            } catch (error) {
                console.error('Error getting recent stations from local storage:', error);
                return [];
            }
        }
        
        // Get most played stations
        async function getMostPlayedStations(limit = 10) {
            try {
                const userId = getOrCreateUserId();
                
                const { data, error } = await supabase
                    .from('station_history')
                    .select('station_id')
                    .eq('user_id', userId);
                
                if (error) throw error;
                
                const counts = {};
                data.forEach(record => {
                    counts[record.station_id] = (counts[record.station_id] || 0) + 1;
                });
                
                // Sort by count and get top station IDs (as numbers)
                const sortedStationIds = Object.keys(counts)
                    .map(id => parseInt(id))
                    .sort((a, b) => counts[b] - counts[a])
                    .slice(0, limit);
                
                return stations.filter(s => sortedStationIds.includes(s.id))
                    .sort((a, b) => counts[b.id] - counts[a.id]);
                
            } catch (error) {
                console.error('Error getting most played stations from database:', error);
                return getMostPlayedStationsLocal(limit);
            }
        }
        
        // Get most played stations from local storage (fallback)
        function getMostPlayedStationsLocal(limit = 10) {
            try {
                const history = JSON.parse(localStorage.getItem('station_history') || '[]');
                
                const counts = {};
                history.forEach(record => {
                    counts[record.station_id] = (counts[record.station_id] || 0) + 1;
                });
                
                // Sort by count and get top station IDs (as numbers)
                const sortedStationIds = Object.keys(counts)
                    .map(id => parseInt(id))
                    .sort((a, b) => counts[b] - counts[a])
                    .slice(0, limit);
                
                return stations.filter(s => sortedStationIds.includes(s.id))
                    .sort((a, b) => counts[b.id] - counts[a.id]);
                
            } catch (error) {
                console.error('Error getting most played stations from local storage:', error);
                return [];
            }
        }
        
        // Load stations from Supabase
        async function loadStations(forceRefresh = false) {
            try {
                console.log('loadStations called');
                const { data, error } = await supabase
                    .from('radio_stations')
                    .select('*')
                    .order('name');
                
                if (error) throw error;
                
                stations = data || [];
                console.log('Loaded stations:', stations.length);
                
                // Populate genre filter dropdown
                populateGenreFilter();
                
                // Re-apply search filter if there's a search term
                const searchTerm = stationSearch ? stationSearch.value.trim() : '';
                if (searchTerm) {
                    console.log('Applying search filter:', searchTerm);
                    filterStations(searchTerm);
                } else {
                    console.log('No search term, setting filteredStations');
                    filteredStations = [...stations];
                    renderStationList();
                }
                
                // Clear service worker cache if force refresh
                if (forceRefresh && 'serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({
                        type: 'CLEAR_CACHE'
                    });
                }
                
            } catch (error) {
                console.error('Error loading stations:', error);
                updateStatus('Error loading stations', 'error');
            }
        }
        
        // Load playlists from Supabase
        async function loadPlaylists(forceRefresh = false) {
            try {
                const { data, error } = await supabase
                    .from('playlists')
                    .select('*, playlist_items(count)')
                    .order('sort_order', { ascending: true, nullsFirst: false })
                    .order('created_at', { ascending: false });
                
                if (error) throw error;
                
                playlists = data || [];
                renderPlaylistsList();
                
                // Clear service worker cache if force refresh
                if (forceRefresh && 'serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({
                        type: 'CLEAR_CACHE'
                    });
                }
                
            } catch (error) {
                console.error('Error loading playlists:', error);
            }
        }
        
        // Load playlist stations
        async function loadPlaylistStations(playlistId) {
            try {
                const { data, error } = await supabase
                    .from('playlist_items')
                    .select('*, radio_stations(*)')
                    .eq('playlist_id', playlistId)
                    .order('created_at');
                
                if (error) throw error;
                
                playlistStations = data.map(item => item.radio_stations);
                renderPlaylistStations();
                
            } catch (error) {
                console.error('Error loading playlist stations:', error);
            }
        }
        
        // Create playlist
        async function createPlaylist(name, description) {
            try {
                console.log('Creating playlist with:', { name, description });
                
                // Get the max sort_order to add new playlist at the end
                const maxSortOrder = playlists.length > 0 
                    ? Math.max(...playlists.map(p => p.sort_order || 0))
                    : -1;
                
                const { data, error } = await supabase
                    .from('playlists')
                    .insert([{ name, description, sort_order: maxSortOrder + 1 }])
                    .select();
                
                if (error) {
                    console.error('Supabase error:', error);
                    console.error('Error details:', JSON.stringify(error, null, 2));
                    throw error;
                }
                
                console.log('Playlist created successfully:', data);
                await loadPlaylists(true); // Force refresh to bypass cache
                alert('Playlist created successfully!');
                return data && data.length > 0 ? data[0] : null;
                
            } catch (error) {
                console.error('Error creating playlist:', error);
                alert(`Failed to create playlist: ${error.message || 'Unknown error'}\n\nCheck browser console for details.`);
                return null;
            }
        }
        
        // Update playlist
        async function updatePlaylist(id, name, description) {
            try {
                console.log('Updating playlist:', { id, name, description });
                
                const { data, error } = await supabase
                    .from('playlists')
                    .update({ name, description })
                    .eq('id', id)
                    .select();
                
                if (error) {
                    console.error('Supabase error:', error);
                    console.error('Error details:', JSON.stringify(error, null, 2));
                    throw error;
                }
                
                console.log('Playlist updated successfully:', data);
                await loadPlaylists(true); // Force refresh to bypass cache
                alert('Playlist updated successfully!');
                
            } catch (error) {
                console.error('Error updating playlist:', error);
                alert(`Failed to update playlist: ${error.message || 'Unknown error'}\n\nCheck browser console for details.`);
            }
        }
        
        // Delete playlist
        async function deletePlaylist(id) {
            try {
                // First delete all playlist items
                await supabase
                    .from('playlist_items')
                    .delete()
                    .eq('playlist_id', id);
                
                // Then delete the playlist
                const { error } = await supabase
                    .from('playlists')
                    .delete()
                    .eq('id', id);
                
                if (error) throw error;
                
                await loadPlaylists(true); // Force refresh to bypass cache
                
            } catch (error) {
                console.error('Error deleting playlist:', error);
                alert('Failed to delete playlist');
            }
        }
        
        // Add station to playlist
        async function addStationToPlaylist(playlistId, stationId) {
            try {
                // Check if station is already in playlist
                const { data: existing } = await supabase
                    .from('playlist_items')
                    .select('id')
                    .eq('playlist_id', playlistId)
                    .eq('station_id', stationId)
                    .single();
                
                if (existing) {
                    alert('Station is already in this playlist');
                    return;
                }
                
                const { error } = await supabase
                    .from('playlist_items')
                    .insert([{ playlist_id: playlistId, station_id: stationId }]);
                
                if (error) throw error;
                
                await loadPlaylists(true); // Force refresh to bypass cache
                
            } catch (error) {
                console.error('Error adding station to playlist:', error);
                alert('Failed to add station to playlist');
            }
        }
        
        // Remove station from playlist
        async function removeStationFromPlaylist(playlistId, stationId) {
            try {
                const { error } = await supabase
                    .from('playlist_items')
                    .delete()
                    .eq('playlist_id', playlistId)
                    .eq('station_id', stationId);
                
                if (error) throw error;
                
                await loadPlaylistStations(playlistId);
                await loadPlaylists(true); // Force refresh to bypass cache
                
            } catch (error) {
                console.error('Error removing station from playlist:', error);
                alert('Failed to remove station from playlist');
            }
        }
        
        // Create station
        async function createStation(stationData) {
            try {
                console.log('Creating station with:', stationData);
                
                const { data, error } = await supabase
                    .from('radio_stations')
                    .insert([stationData])
                    .select();
                
                if (error) {
                    console.error('Supabase error:', error);
                    console.error('Error details:', JSON.stringify(error, null, 2));
                    throw error;
                }
                
                console.log('Station created successfully:', data);
                await loadStations(true); // Force refresh to bypass cache
                alert('Station created successfully!');
                return data && data.length > 0 ? data[0] : null;
                
            } catch (error) {
                console.error('Error creating station:', error);
                alert(`Failed to create station: ${error.message || 'Unknown error'}\n\nCheck browser console for details.`);
                return null;
            }
        }
        
        // Update station
        async function updateStation(id, stationData) {
            try {
                console.log('Updating station:', { id, stationData });
                
                const { data, error } = await supabase
                    .from('radio_stations')
                    .update(stationData)
                    .eq('id', id)
                    .select();
                
                if (error) {
                    console.error('Supabase error:', error);
                    console.error('Error details:', JSON.stringify(error, null, 2));
                    throw error;
                }
                
                console.log('Station updated successfully:', data);
                await loadStations(true); // Force refresh to bypass cache
                alert('Station updated successfully!');
                
            } catch (error) {
                console.error('Error updating station:', error);
                console.error('Error message:', error.message);
                console.error('Error details:', error.details);
                console.error('Error hint:', error.hint);
                alert(`Failed to update station: ${error.message || 'Unknown error'}\n\nCheck browser console for details.`);
            }
        }
        
        // Delete station
        async function deleteStation(id) {
            try {
                // First delete from all playlists
                await supabase
                    .from('playlist_items')
                    .delete()
                    .eq('station_id', id);
                
                // Then delete the station
                const { error } = await supabase
                    .from('radio_stations')
                    .delete()
                    .eq('id', id);
                
                if (error) throw error;
                
                await loadStations(true); // Force refresh to bypass cache
                await loadPlaylists(true); // Force refresh to bypass cache
                
            } catch (error) {
                console.error('Error deleting station:', error);
                alert('Failed to delete station');
            }
        }
        
        // ======================
        // UI FUNCTIONS
        // ======================
        
        // Render playlists list
        function renderPlaylistsList() {
            // Apply grid view class if in grid mode
            if (playlistViewMode === 'grid') {
                playlistsList.classList.add('grid-view');
            } else {
                playlistsList.classList.remove('grid-view');
            }
            
            // Start with empty content (history buttons moved to main page)
            let htmlContent = '';
            
            if (playlists.length === 0) {
                htmlContent += `
                    <div class="empty-state">
                        <div class="empty-state-icon">ðŸ“</div>
                        <div class="empty-state-text">No custom playlists yet. Create one to organize your favorite stations!</div>
                    </div>
                `;
            } else {
                htmlContent += playlists.map(playlist => {
                    const count = playlist.playlist_items?.[0]?.count || 0;
                    return `
                        <div class="playlist-item" data-id="${playlist.id}" draggable="true">
                            <div class="playlist-drag-handle">â‹®â‹®</div>
                            <div class="playlist-icon">ðŸŽµ</div>
                            <div class="playlist-info">
                                <div class="playlist-name">${escapeHtml(playlist.name)}</div>
                                <div class="playlist-count">${count} ${count === 1 ? 'station' : 'stations'}</div>
                            </div>
                            <button class="playlist-menu-btn" data-id="${playlist.id}">â‹®</button>
                            <div class="playlist-dropdown">
                                <div class="dropdown-item" data-action="view" data-playlist-id="${playlist.id}">
                                    <span>ðŸ“»</span> View Playlist
                                </div>
                                <div class="dropdown-item" data-action="edit" data-playlist-id="${playlist.id}">
                                    <span>âœï¸</span> Rename
                                </div>
                                <div class="dropdown-divider"></div>
                                <div class="dropdown-item danger" data-action="delete" data-playlist-id="${playlist.id}">
                                    <span>ðŸ—‘ï¸</span> Delete
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            playlistsList.innerHTML = htmlContent;
            
            // Add event listeners for playlist items
            document.querySelectorAll('.playlist-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.playlist-menu-btn') && !e.target.closest('.playlist-dropdown')) {
                        const id = item.dataset.id;
                        openPlaylist(id);
                    }
                });
            });
            
            // Setup drag and drop for reordering playlists
            setupPlaylistDragAndDrop();
            
            // Add event listeners for playlist menu buttons
            document.querySelectorAll('.playlist-menu-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const dropdown = btn.nextElementSibling;
                    
                    // Close all other dropdowns
                    document.querySelectorAll('.playlist-dropdown').forEach(d => {
                        if (d !== dropdown) d.classList.remove('active');
                    });
                    
                    dropdown.classList.toggle('active');
                });
            });
            
            // Add event listeners for dropdown items
            document.querySelectorAll('.playlist-dropdown .dropdown-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = item.dataset.action;
                    const playlistId = item.dataset.playlistId;
                    
                    if (!action || !playlistId) return;
                    
                    // Close dropdown
                    item.closest('.playlist-dropdown').classList.remove('active');
                    
                    if (action === 'view') {
                        openPlaylist(playlistId);
                    } else if (action === 'edit') {
                        editPlaylist(playlistId);
                    } else if (action === 'delete') {
                        confirmDeletePlaylist(playlistId);
                    }
                });
            });
        }
        
        // Setup drag and drop for playlist reordering
        function setupPlaylistDragAndDrop() {
            const playlistItems = document.querySelectorAll('.playlist-item');
            let draggedElement = null;
            let draggedIndex = null;
            
            playlistItems.forEach((item, index) => {
                // Drag start
                item.addEventListener('dragstart', (e) => {
                    draggedElement = item;
                    draggedIndex = index;
                    item.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', item.innerHTML);
                });
                
                // Drag end
                item.addEventListener('dragend', (e) => {
                    item.classList.remove('dragging');
                    // Remove drag-over class from all items
                    document.querySelectorAll('.playlist-item').forEach(i => {
                        i.classList.remove('drag-over');
                    });
                });
                
                // Drag over
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    if (item !== draggedElement) {
                        item.classList.add('drag-over');
                    }
                });
                
                // Drag leave
                item.addEventListener('dragleave', (e) => {
                    item.classList.remove('drag-over');
                });
                
                // Drop
                item.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    item.classList.remove('drag-over');
                    
                    if (draggedElement !== item) {
                        // Get the indices
                        const dropIndex = Array.from(playlistItems).indexOf(item);
                        
                        // Reorder the playlists array
                        const movedPlaylist = playlists.splice(draggedIndex, 1)[0];
                        playlists.splice(dropIndex, 0, movedPlaylist);
                        
                        // Update sort orders and save to database
                        await updatePlaylistOrder();
                        
                        // Re-render the list
                        renderPlaylistsList();
                    }
                });
            });
        }
        
        // Update playlist order in database
        async function updatePlaylistOrder() {
            try {
                // Update each playlist with its new sort_order
                const updates = playlists.map((playlist, index) => {
                    return supabase
                        .from('playlists')
                        .update({ sort_order: index })
                        .eq('id', playlist.id);
                });
                
                await Promise.all(updates);
                console.log('Playlist order updated successfully');
                
            } catch (error) {
                console.error('Error updating playlist order:', error);
                alert('Failed to save playlist order');
            }
        }
        
        // Render station list
        function renderStationList() {
            console.log('renderStationList called', {
                stationList: stationList,
                filteredStationsLength: filteredStations.length,
                stationsLength: stations.length
            });
            
            if (!stationList) {
                console.error('stationList element not found!');
                return;
            }
            
            // Apply grid view class if in grid mode
            if (stationViewMode === 'grid') {
                stationList.classList.add('grid-view');
            } else {
                stationList.classList.remove('grid-view');
            }
            
            if (filteredStations.length === 0) {
                stationList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">ðŸ“»</div>
                        <div class="empty-state-text">
                            ${stations.length === 0 ? 'No stations yet. Add one to get started!' : 'No stations found.'}
                        </div>
                    </div>
                `;
                return;
            }
            
            stationList.innerHTML = filteredStations.map(station => {
                // Handle genres as array or string
                const genresDisplay = station.genres && Array.isArray(station.genres)
                    ? station.genres.join(', ')
                    : (station.genres || 'No genres');
                
                // Build station details (call letters and frequency)
                const detailsParts = [];
                if (station.call_letters) {
                    detailsParts.push(station.call_letters);
                }
                if (station.frequency) {
                    detailsParts.push(station.frequency);
                }
                const detailsDisplay = detailsParts.length > 0 ? detailsParts.join(' â€¢ ') : '';
                
                return `
                <div class="station-item ${currentStation?.id === station.id ? 'selected' : ''}" data-id="${station.id}">
                    ${station.icon_url ? 
                        `<img src="${station.icon_url}" class="station-icon" alt="${escapeHtml(station.name)}">` :
                        `<div class="station-icon">ðŸ“»</div>`
                    }
                    <div class="station-info">
                        <div class="station-name">${escapeHtml(station.name)}</div>
                        ${detailsDisplay ? `<div class="station-details">${escapeHtml(detailsDisplay)}</div>` : ''}
                        <div class="station-genres">${escapeHtml(genresDisplay)}</div>
                    </div>
                    <button class="station-menu-btn" data-id="${station.id}">â‹®</button>
                    <div class="station-dropdown">
                        <div class="dropdown-submenu">
                            <div class="dropdown-item">
                                <span>âž•</span> Add to Playlist
                            </div>
                            <div class="dropdown-submenu-content">
                                ${playlists.length === 0 ? 
                                    `<div class="dropdown-item" data-action="create-playlist">
                                        <span>ðŸ“</span> Create Playlist
                                    </div>` :
                                    playlists.map(playlist => `
                                        <div class="dropdown-item" data-action="add-to-playlist" data-playlist-id="${playlist.id}" data-station-id="${station.id}">
                                            ${escapeHtml(playlist.name)}
                                        </div>
                                    `).join('')
                                }
                            </div>
                        </div>
                        <div class="dropdown-divider"></div>
                        <div class="dropdown-item" data-action="edit-station" data-station-id="${station.id}">
                            <span>âœï¸</span> Edit Station
                        </div>
                        <div class="dropdown-item danger" data-action="delete-station" data-station-id="${station.id}">
                            <span>ðŸ—‘ï¸</span> Delete Station
                        </div>
                    </div>
                </div>
            `;
            }).join('');
            
            // Add event listeners
            document.querySelectorAll('.station-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.station-menu-btn') && !e.target.closest('.station-dropdown')) {
                        const id = parseInt(item.dataset.id);
                        const station = stations.find(s => s.id === id);
                        selectStation(station);
                    }
                });
            });
            
            // Add event listeners for menu buttons
            document.querySelectorAll('.station-menu-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const dropdown = btn.nextElementSibling;
                    
                    // Close all other dropdowns
                    document.querySelectorAll('.station-dropdown').forEach(d => {
                        if (d !== dropdown) d.classList.remove('active');
                    });
                    
                    dropdown.classList.toggle('active');
                });
            });
            
            // Add hover/click listeners for submenus (mobile support)
            document.querySelectorAll('.dropdown-submenu').forEach(submenu => {
                // Support click for mobile
                submenu.addEventListener('click', (e) => {
                    if (e.target.closest('.dropdown-item') && !e.target.dataset.action) {
                        e.stopPropagation();
                        submenu.classList.toggle('active');
                    }
                });
                
                // Close submenu when clicking on backdrop (mobile)
                submenu.addEventListener('click', (e) => {
                    if (e.target === submenu && submenu.classList.contains('active')) {
                        submenu.classList.remove('active');
                    }
                });
            });
            
            // Add event listeners for dropdown actions
            document.querySelectorAll('.station-dropdown .dropdown-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = item.dataset.action;
                    
                    if (action === 'create-playlist') {
                        showPlaylistForm();
                        document.querySelectorAll('.station-dropdown').forEach(d => d.classList.remove('active'));
                    } else if (action === 'add-to-playlist') {
                        const playlistId = item.dataset.playlistId;
                        const stationId = parseInt(item.dataset.stationId);
                        addToPlaylist(playlistId, stationId);
                        document.querySelectorAll('.station-dropdown').forEach(d => d.classList.remove('active'));
                    } else if (action === 'edit-station') {
                        const stationId = parseInt(item.dataset.stationId);
                        editStation(stationId);
                        document.querySelectorAll('.station-dropdown').forEach(d => d.classList.remove('active'));
                    } else if (action === 'delete-station') {
                        const stationId = parseInt(item.dataset.stationId);
                        confirmDeleteStation(stationId);
                        document.querySelectorAll('.station-dropdown').forEach(d => d.classList.remove('active'));
                    }
                });
            });
        }
        
        // Render playlist stations
        function renderPlaylistStations() {
            // Apply grid view class if in grid mode
            if (playlistStationViewMode === 'grid') {
                playlistStationList.classList.add('grid-view');
            } else {
                playlistStationList.classList.remove('grid-view');
            }
            
            if (playlistStations.length === 0) {
                playlistStationList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">ðŸ“»</div>
                        <div class="empty-state-text">No stations in this playlist yet.</div>
                    </div>
                `;
                return;
            }
            
            playlistStationList.innerHTML = playlistStations.map(station => {
                // Handle genres as array or string
                const genresDisplay = station.genres && Array.isArray(station.genres)
                    ? station.genres.join(', ')
                    : (station.genres || 'No genres');
                
                // Build station details (call letters and frequency)
                const detailsParts = [];
                if (station.call_letters) {
                    detailsParts.push(station.call_letters);
                }
                if (station.frequency) {
                    detailsParts.push(station.frequency);
                }
                const detailsDisplay = detailsParts.length > 0 ? detailsParts.join(' â€¢ ') : '';
                
                return `
                <div class="station-item ${currentStation?.id === station.id ? 'selected' : ''}" data-id="${station.id}">
                    ${station.icon_url ? 
                        `<img src="${station.icon_url}" class="station-icon" alt="${escapeHtml(station.name)}">` :
                        `<div class="station-icon">ðŸ“»</div>`
                    }
                    <div class="station-info">
                        <div class="station-name">${escapeHtml(station.name)}</div>
                        ${detailsDisplay ? `<div class="station-details">${escapeHtml(detailsDisplay)}</div>` : ''}
                        <div class="station-genres">${escapeHtml(genresDisplay)}</div>
                    </div>
                    <button class="station-menu-btn" data-id="${station.id}">â‹®</button>
                    <div class="station-dropdown">
                        <div class="dropdown-item danger" data-action="remove-from-playlist" data-playlist-id="${currentPlaylist.id}" data-station-id="${station.id}">
                            <span>âž–</span> Remove from Playlist
                        </div>
                    </div>
                </div>
            `;
            }).join('');
            
            // Add event listeners
            document.querySelectorAll('#playlistStationList .station-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.station-menu-btn') && !e.target.closest('.station-dropdown')) {
                        const id = parseInt(item.dataset.id);
                        const station = playlistStations.find(s => s.id === id);
                        selectStation(station);
                        closePlaylistModal.click();
                    }
                });
            });
            
            // Add event listeners for menu buttons
            document.querySelectorAll('#playlistStationList .station-menu-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const dropdown = btn.nextElementSibling;
                    
                    // Close all other dropdowns
                    document.querySelectorAll('#playlistStationList .station-dropdown').forEach(d => {
                        if (d !== dropdown) d.classList.remove('active');
                    });
                    
                    dropdown.classList.toggle('active');
                });
            });
            
            // Add event listeners for dropdown actions
            document.querySelectorAll('#playlistStationList .dropdown-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = item.dataset.action;
                    
                    if (action === 'remove-from-playlist') {
                        const playlistId = item.dataset.playlistId;
                        const stationId = parseInt(item.dataset.stationId);
                        removeFromPlaylist(playlistId, stationId);
                        document.querySelectorAll('.station-dropdown').forEach(d => d.classList.remove('active'));
                    }
                });
            });
        }
        
        // Select station
        function selectStation(station) {
            currentStation = station;
            
            // Track the station click
            trackStationClick(station.id);
            
            // Update display - keep it visible along with buttons
            stationDisplay.style.display = 'flex';
            // Don't hide the selector buttons anymore
            // stationSelectorButtons.style.display = 'none';
            stationDisplayIcon.src = station.icon_url || '';
            stationDisplayIcon.style.display = station.icon_url ? 'block' : 'none';
            stationDisplayName.textContent = station.name;
            
            
            // Display call letters and frequency
            const detailsParts = [];
            if (station.call_letters) {
                detailsParts.push(station.call_letters);
            }
            if (station.frequency) {
                detailsParts.push(station.frequency);
            }
            const stationDisplayDetails = document.getElementById('stationDisplayDetails');
            stationDisplayDetails.textContent = detailsParts.length > 0 ? detailsParts.join(' â€¢ ') : '';
            stationDisplayDetails.style.display = detailsParts.length > 0 ? 'block' : 'none';
            
            // Update quality button availability
            updateQualityButtons(station);
            
            playPauseBtn.disabled = false;

            // Stop current stream if playing before starting new one
            if (player) {
                player.stop();
            }

            // Close modals
            browseStationsModal.classList.remove('active');
            playlistsModal.classList.remove('active');
            playlistModal.classList.remove('active');
            
            // Re-render lists to update selected state
            renderStationList();
            if (currentPlaylist) {
                renderPlaylistStations();
            }


            // Automatically start playing the station
            setTimeout(() => {
                playPauseBtn.click();
            }, 100);


        }
        
        // Update quality button availability based on station URLs
        function updateQualityButtons(station) {
            const lowBtn = document.querySelector('.quality-option-modal[data-quality="low"]');
            const standardBtn = document.querySelector('.quality-option-modal[data-quality="standard"]');
            const highBtn = document.querySelector('.quality-option-modal[data-quality="high"]');
            const qualityBtn = document.getElementById('qualityBtn');
            
            let hasMultipleQualities = false;
            
            // Enable/disable based on available URLs
            if (station.url_low) {
                lowBtn.classList.remove('disabled');
                hasMultipleQualities = true;
            } else {
                lowBtn.classList.add('disabled');
                if (selectedQuality === 'low') {
                    // Switch to standard if low was selected but not available
                    selectedQuality = 'standard';
                    standardBtn.classList.add('selected');
                    lowBtn.classList.remove('selected');
                    document.getElementById('currentQuality').textContent = 'Standard';
                }
            }
            
            // Standard URL is always required, so always enabled
            standardBtn.classList.remove('disabled');
            
            if (station.url_high) {
                highBtn.classList.remove('disabled');
                hasMultipleQualities = true;
            } else {
                highBtn.classList.add('disabled');
                if (selectedQuality === 'high') {
                    // Switch to standard if high was selected but not available
                    selectedQuality = 'standard';
                    standardBtn.classList.add('selected');
                    highBtn.classList.remove('selected');
                    document.getElementById('currentQuality').textContent = 'Standard';
                }
            }
            
            // Only show quality button if there are multiple quality options
            if (hasMultipleQualities) {
                qualityBtn.classList.add('visible');
            } else {
                qualityBtn.classList.remove('visible');
            }
        }
        
        // Open playlist
        function openPlaylist(id) {
            currentPlaylist = playlists.find(p => p.id === id);
            if (!currentPlaylist) return;
            
            playlistModalTitle.textContent = currentPlaylist.name;
            loadPlaylistStations(id);
            
            playlistsModal.classList.remove('active');
            playlistModal.classList.add('active');
        }
        
        // Show playlist form
        function showPlaylistForm(id = null) {
            editingPlaylistId = id;
            
            if (id) {
                const playlist = playlists.find(p => p.id === id);
                if (!playlist) return;
                
                playlistFormTitle.textContent = 'Edit Playlist';
                playlistName.value = playlist.name;
                playlistDescription.value = playlist.description || '';
            } else {
                playlistFormTitle.textContent = 'Create Playlist';
                playlistName.value = '';
                playlistDescription.value = '';
            }
            
            // Close dropdowns
            document.querySelectorAll('.playlist-dropdown, .station-dropdown').forEach(d => {
                d.classList.remove('active');
            });
            
            playlistFormModal.classList.add('active');
        }
        
        // Edit playlist
        function editPlaylist(id) {
            showPlaylistForm(id);
        }
        
        // Confirm delete playlist
        function confirmDeletePlaylist(id) {
            const playlist = playlists.find(p => p.id === id);
            if (!playlist) return;
            
            if (confirm(`Are you sure you want to delete "${playlist.name}"?`)) {
                deletePlaylist(id);
            }
        }
        
        // Add station to playlist
        function addToPlaylist(playlistId, stationId) {
            addStationToPlaylist(playlistId, stationId);
            
            // Close dropdown
            document.querySelectorAll('.station-dropdown').forEach(d => {
                d.classList.remove('active');
            });
        }
        
        // Remove station from playlist
        function removeFromPlaylist(playlistId, stationId) {
            if (confirm('Remove this station from the playlist?')) {
                removeStationFromPlaylist(playlistId, stationId);
            }
            
            // Close dropdown
            document.querySelectorAll('.station-dropdown').forEach(d => {
                d.classList.remove('active');
            });
        }
        
        // Show station form
        function showStationForm(id = null) {
            editingStationId = id;
            
            if (id) {
                const station = stations.find(s => s.id === id);
                if (!station) return;
                
                stationFormTitle.textContent = 'Edit Station';
                document.getElementById('stationFormName').value = station.name;
                document.getElementById('stationFormUrl').value = station.url;
                document.getElementById('stationFormUrlLow').value = station.url_low || '';
                document.getElementById('stationFormUrlHigh').value = station.url_high || '';
                
                // Convert genres array to comma-separated string for display
                // If genres is ["News", "Talk"], display as "News, Talk"
                const genresDisplay = station.genres && Array.isArray(station.genres) 
                    ? station.genres.join(', ') 
                    : (station.genres || '');
                document.getElementById('stationFormGenres').value = genresDisplay;
                
                document.getElementById('stationFormIconUrl').value = station.icon_url || '';
            } else {
                stationFormTitle.textContent = 'Add Station';
                stationForm.reset();
            }
            
            // Close dropdowns
            document.querySelectorAll('.station-dropdown').forEach(d => {
                d.classList.remove('active');
            });
            
            stationFormModal.classList.add('active');
        }
        
        // Edit station
        function editStation(id) {
            showStationForm(id);
        }
        
        // Confirm delete station
        function confirmDeleteStation(id) {
            const station = stations.find(s => s.id === id);
            if (!station) return;
            
            if (confirm(`Are you sure you want to delete "${station.name}"?`)) {
                deleteStation(id);
            }
        }
        
        // Filter stations
        function filterStations(query) {
            console.log('filterStations called with query:', query);
            console.log('Total stations:', stations.length);
            const lowerQuery = query.toLowerCase();
            filteredStations = stations.filter(station => {
                // First apply genre filter
                if (currentGenreFilter) {
                    let hasGenre = false;
                    if (Array.isArray(station.genres)) {
                        hasGenre = station.genres.some(g => 
                            g.toLowerCase() === currentGenreFilter.toLowerCase()
                        );
                    } else if (typeof station.genres === 'string') {
                        hasGenre = station.genres.toLowerCase().includes(currentGenreFilter.toLowerCase());
                    }
                    if (!hasGenre) return false;
                }
                
                // Then apply search query if present
                if (!query) return true;
                
                const nameMatch = station.name && station.name.toLowerCase().includes(lowerQuery);
                
                // Handle genres as array or string
                let genresMatch = false;
                if (station.genres) {
                    if (Array.isArray(station.genres)) {
                        // Search in array elements
                        genresMatch = station.genres.some(genre => 
                            genre.toLowerCase().includes(lowerQuery)
                        );
                    } else if (typeof station.genres === 'string') {
                        // Handle as string (for backward compatibility)
                        genresMatch = station.genres.toLowerCase().includes(lowerQuery);
                    }
                }
                
                return nameMatch || genresMatch;
            });
            console.log('Filtered stations:', filteredStations.length);
            sortStations(); // Apply current sort after filtering
        }
        
        // Populate genre filter dropdown
        function populateGenreFilter() {
            const genreSet = new Set();
            const genreCounts = {};
            
            stations.forEach(station => {
                if (Array.isArray(station.genres)) {
                    station.genres.forEach(genre => {
                        if (genre && genre.trim()) {
                            genreSet.add(genre.trim());
                            genreCounts[genre.trim()] = (genreCounts[genre.trim()] || 0) + 1;
                        }
                    });
                } else if (typeof station.genres === 'string' && station.genres.trim()) {
                    // Split by comma for string genres
                    station.genres.split(',').forEach(genre => {
                        const trimmedGenre = genre.trim();
                        if (trimmedGenre) {
                            genreSet.add(trimmedGenre);
                            genreCounts[trimmedGenre] = (genreCounts[trimmedGenre] || 0) + 1;
                        }
                    });
                }
            });
            
            const sortedGenres = Array.from(genreSet).sort();
            
            // Build dropdown HTML
            let dropdownHTML = `
                <div class="filter-option active" data-genre="">
                    <span class="filter-option-icon">ðŸŽµ</span>
                    <span>All Genres</span>
                    <span class="genre-count">${stations.length}</span>
                </div>
            `;
            
            sortedGenres.forEach(genre => {
                dropdownHTML += `
                    <div class="filter-option" data-genre="${escapeHtml(genre)}">
                        <span class="filter-option-icon">ðŸŽµ</span>
                        <span>${escapeHtml(genre)}</span>
                        <span class="genre-count">${genreCounts[genre]}</span>
                    </div>
                `;
            });
            
            genreDropdown.innerHTML = dropdownHTML;
            
            // Re-attach event listeners
            genreDropdown.querySelectorAll('.filter-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    // Update active state
                    genreDropdown.querySelectorAll('.filter-option').forEach(opt => opt.classList.remove('active'));
                    option.classList.add('active');
                    
                    // Update genre filter
                    currentGenreFilter = option.dataset.genre;
                    
                    // Update button label
                    genreLabel.textContent = option.dataset.genre || 'All Genres';
                    
                    // Close dropdown
                    genreDropdown.classList.remove('active');
                    
                    // Apply filter
                    filterStations(stationSearch.value);
                });
            });
        }
        
        // Sort stations based on current sort method
        async function sortStations() {
            console.log('Sorting stations by:', currentSortMethod);
            
            switch(currentSortMethod) {
                case 'name-asc':
                    filteredStations.sort((a, b) => 
                        (a.name || '').localeCompare(b.name || '')
                    );
                    break;
                    
                case 'name-desc':
                    filteredStations.sort((a, b) => 
                        (b.name || '').localeCompare(a.name || '')
                    );
                    break;
                    
                case 'most-played':
                    const mostPlayed = await getMostPlayedStations(filteredStations.length);
                    const mostPlayedIds = mostPlayed.map(s => s.id);
                    filteredStations.sort((a, b) => {
                        const indexA = mostPlayedIds.indexOf(a.id);
                        const indexB = mostPlayedIds.indexOf(b.id);
                        if (indexA === -1 && indexB === -1) return 0;
                        if (indexA === -1) return 1;
                        if (indexB === -1) return -1;
                        return indexA - indexB;
                    });
                    break;
                    
                case 'recent':
                    const recentStations = await getMostRecentStations(filteredStations.length);
                    const recentIds = recentStations.map(s => s.id);
                    filteredStations.sort((a, b) => {
                        const indexA = recentIds.indexOf(a.id);
                        const indexB = recentIds.indexOf(b.id);
                        if (indexA === -1 && indexB === -1) return 0;
                        if (indexA === -1) return 1;
                        if (indexB === -1) return -1;
                        return indexA - indexB;
                    });
                    break;
            }
            
            renderStationList();
        }
        
        // Update status
        function updateStatus(message, type = 'default') {
            statusText.textContent = message;
            statusDot.className = 'status-dot';
            
            if (type === 'playing') {
                statusDot.classList.add('playing');
            } else if (type === 'error') {
                statusDot.classList.add('error');
            } else if (type === 'loading') {
                statusDot.classList.add('loading');
            }
        }
        
        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // ======================
        // EVENT LISTENERS
        // ======================
        
        // Open playlists modal
        playlistsBtn.addEventListener('click', () => {
            playlistsModal.classList.add('active');
            loadPlaylists();
        });
        
        // Open browse stations modal
        browseStationsBtn.addEventListener('click', () => {
            console.log('Opening browse stations modal', {
                stationsLength: stations.length,
                filteredStationsLength: filteredStations.length
            });
            browseStationsModal.classList.add('active');
            // Ensure stations are displayed
            if (stations.length > 0) {
                if (filteredStations.length === 0) {
                    console.log('Initializing filteredStations');
                    filteredStations = [...stations];
                }
                console.log('Calling renderStationList');
                renderStationList();
            } else {
                console.log('No stations loaded yet');
            }
        });
        
        // Most Recent Stations button
        document.getElementById('recentStationsBtn').addEventListener('click', async () => {
            const recentStations = await getMostRecentStations(10);
            if (recentStations.length === 0) {
                alert('No recent stations yet. Start listening to build your history!');
                return;
            }
            // Open in playlist modal
            playlistStations = recentStations;
            currentPlaylist = { id: 'recent', name: 'Most Recent Stations' };
            playlistModalTitle.textContent = 'Most Recent Stations';
            renderPlaylistStations();
            playlistModal.classList.add('active');
        });
        
        // Most Played Stations button
        document.getElementById('mostPlayedBtn').addEventListener('click', async () => {
            const playedStations = await getMostPlayedStations(10);
            if (playedStations.length === 0) {
                alert('No play history yet. Start listening to see your favorites!');
                return;
            }
            // Open in playlist modal
            playlistStations = playedStations;
            currentPlaylist = { id: 'played', name: 'Most Played Stations' };
            playlistModalTitle.textContent = 'Most Played Stations';
            renderPlaylistStations();
            playlistModal.classList.add('active');
        });
        
        // Station display is now just informational - no click functionality
        // Removed click listener that opened browse stations modal
        
        // Close playlists modal
        closePlaylistsModal.addEventListener('click', () => {
            playlistsModal.classList.remove('active');
        });
        
        // Close browse stations modal
        closeBrowseStationsModal.addEventListener('click', () => {
            browseStationsModal.classList.remove('active');
        });
        
        // Open settings modal
        settingsBtn.addEventListener('click', () => {
            settingsModal.classList.add('active');
        });
        
        // Close settings modal
        closeSettingsModal.addEventListener('click', () => {
            settingsModal.classList.remove('active');
        });
        
        // Close settings modal when clicking outside
        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) {
                settingsModal.classList.remove('active');
            }
        });
        
        // Theme Toggle Functionality
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        
        // Load saved theme or default to dark
        const savedTheme = localStorage.getItem('theme') || 'dark';
        html.setAttribute('data-theme', savedTheme);
        updateThemeToggleUI(savedTheme);
        
        // Theme toggle click handler
        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeToggleUI(newTheme);
        });
        
        // Update theme toggle UI based on current theme
        function updateThemeToggleUI(theme) {
            const darkOption = themeToggle.querySelector('[data-theme="dark"]');
            const lightOption = themeToggle.querySelector('[data-theme="light"]');
            
            if (theme === 'dark') {
                darkOption.classList.add('active');
                lightOption.classList.remove('active');
            } else {
                darkOption.classList.remove('active');
                lightOption.classList.add('active');
            }
        }
        
        // Liked Tracks Modal event listeners
        viewLikedTracksBtn.addEventListener('click', () => {
            displayLikedTracks();
            settingsModal.classList.remove('active');
            likedTracksModal.classList.add('active');
        });
        
        closeLikedTracksModal.addEventListener('click', () => {
            likedTracksModal.classList.remove('active');
        });
        
        likedTracksModal.addEventListener('click', (e) => {
            if (e.target === likedTracksModal) {
                likedTracksModal.classList.remove('active');
            }
        });
        
        clearAllLikesBtn.addEventListener('click', clearAllLikedTracks);
        
        // Close playlist modal
        closePlaylistModal.addEventListener('click', () => {
            playlistModal.classList.remove('active');
            currentPlaylist = null;
        });
        
        // Back to stations (from playlist detail view)
        backToStations.addEventListener('click', () => {
            playlistModal.classList.remove('active');
            playlistsModal.classList.add('active');
            currentPlaylist = null;
        });
        
        // Create playlist button
        createPlaylistBtn.addEventListener('click', () => {
            showPlaylistForm();
        });
        
        // Add station button
        document.getElementById('addStationBtn').addEventListener('click', () => {
            showStationForm();
        });
        
        // Playlist form
        playlistForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const name = playlistName.value.trim();
            const description = playlistDescription.value.trim();
            
            if (!name) return;
            
            if (editingPlaylistId) {
                await updatePlaylist(editingPlaylistId, name, description);
            } else {
                await createPlaylist(name, description);
            }
            
            playlistFormModal.classList.remove('active');
            editingPlaylistId = null;
        });
        
        // Close playlist form
        closePlaylistFormModal.addEventListener('click', () => {
            playlistFormModal.classList.remove('active');
            editingPlaylistId = null;
        });
        
        cancelPlaylistForm.addEventListener('click', () => {
            playlistFormModal.classList.remove('active');
            editingPlaylistId = null;
        });
        
        // Station form
        stationForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // Get form values
            const name = document.getElementById('stationFormName').value.trim();
            const url = document.getElementById('stationFormUrl').value.trim();
            const url_low = document.getElementById('stationFormUrlLow').value.trim() || null;
            const url_high = document.getElementById('stationFormUrlHigh').value.trim() || null;
            const genresInput = document.getElementById('stationFormGenres').value.trim();
            const icon_url = document.getElementById('stationFormIconUrl').value.trim() || null;
            
            // Validate required fields
            if (!name || !url) {
                alert('Station name and URL are required!');
                return;
            }
            
            // Convert genres string to array if needed
            // If user enters "News,Talk" or "News, Talk", convert to ["News", "Talk"]
            let genres = null;
            if (genresInput) {
                // Split by comma and trim whitespace from each genre
                genres = genresInput.split(',').map(g => g.trim()).filter(g => g.length > 0);
            }
            
            const stationData = {
                name: name,
                url: url,
                url_low: url_low,
                url_high: url_high,
                genres: genres, // Now an array like ["News", "Talk"] or null
                icon_url: icon_url
            };
            
            console.log('Form submission - editingStationId:', editingStationId);
            console.log('Form submission - stationData:', stationData);
            
            if (editingStationId) {
                await updateStation(editingStationId, stationData);
            } else {
                await createStation(stationData);
            }
            
            stationFormModal.classList.remove('active');
            editingStationId = null;
        });
        
        // Close station form
        closeStationFormModal.addEventListener('click', () => {
            stationFormModal.classList.remove('active');
            editingStationId = null;
        });
        
        cancelStationForm.addEventListener('click', () => {
            stationFormModal.classList.remove('active');
            editingStationId = null;
        });
        
        // Search stations
        // Search input handler
        stationSearch.addEventListener('input', (e) => {
            console.log('Search input event fired, value:', e.target.value);
            filterStations(e.target.value);
        });
        
        // Genre dropdown toggle
        genreBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            genreDropdown.classList.toggle('active');
            sortDropdown.classList.remove('active'); // Close sort dropdown
        });
        
        // Sort dropdown toggle
        sortBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            sortDropdown.classList.toggle('active');
            genreDropdown.classList.remove('active'); // Close genre dropdown
        });
        
        // Sort option selection
        document.querySelectorAll('.filter-dropdown#sortDropdown .filter-option').forEach(option => {
            option.addEventListener('click', async (e) => {
                e.stopPropagation();
                
                // Update active state
                document.querySelectorAll('.filter-dropdown#sortDropdown .filter-option').forEach(opt => opt.classList.remove('active'));
                option.classList.add('active');
                
                // Update sort method
                currentSortMethod = option.dataset.sort;
                
                // Update button label
                sortLabel.textContent = option.textContent.trim();
                
                // Close dropdown
                sortDropdown.classList.remove('active');
                
                // Apply sort
                await sortStations();
            });
        });
        
        // Quality modal
        const qualityBtn = document.getElementById('qualityBtn');
        const qualityModal = document.getElementById('qualityModal');
        const closeQualityModal = document.getElementById('closeQualityModal');
        const currentQualityText = document.getElementById('currentQuality');
        
        qualityBtn.addEventListener('click', () => {
            qualityModal.classList.add('active');
        });
        
        closeQualityModal.addEventListener('click', () => {
            qualityModal.classList.remove('active');
        });
        
        qualityModal.addEventListener('click', (e) => {
            if (e.target === qualityModal) {
                qualityModal.classList.remove('active');
            }
        });
        
        // Quality option selection
        document.querySelectorAll('.quality-option-modal').forEach(option => {
            option.addEventListener('click', () => {
                // Don't allow selecting disabled options
                if (option.classList.contains('disabled')) {
                    return;
                }
                
                // Check if this is already selected
                if (option.classList.contains('selected')) {
                    qualityModal.classList.remove('active');
                    return;
                }
                
                const wasPlaying = isPlaying;
                const newQuality = option.dataset.quality;
                
                document.querySelectorAll('.quality-option-modal').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                selectedQuality = newQuality;
                
                // Update button text
                const qualityNames = {
                    'low': 'Low',
                    'standard': 'Standard',
                    'high': 'High'
                };
                currentQualityText.textContent = qualityNames[newQuality];
                
                // Close modal
                qualityModal.classList.remove('active');
                
                // If player was playing, stop and restart with new quality
                if (wasPlaying && currentStation && player) {
                    console.log(`Switching to ${newQuality} quality...`);
                    updateStatus(`Switching to ${newQuality} quality...`, 'loading');
                    
                    // Stop the current stream
                    player.stop();
                    
                    // Wait a moment for the stop to complete, then start new stream
                    setTimeout(() => {
                        playPauseBtn.click();
                    }, 200);
                }
            });
        });
        
        // Close modals on overlay click
        [playlistsModal, browseStationsModal, playlistModal, playlistFormModal, stationFormModal, qualityModal].forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            });
        });
        
        // ======================
        // METADATA DISPLAY
        // ======================
        
        // Helper function to display station icon
        function displayStationIcon() {
            if (currentStation && currentStation.icon_url) {
                artworkContainer.innerHTML = `<img src="${escapeHtml(currentStation.icon_url)}" alt="${escapeHtml(currentStation.name)}" class="album-art">`;
            } else {
                artworkContainer.innerHTML = `<div class="album-art-placeholder">ðŸŽµ</div>`;
            }
        }
        
        // Display metadata
        function displayMetadata(metadata) {
            if (!metadata || !metadata.StreamTitle) {
                metadataDiv.innerHTML = `
                    <div class="now-playing-label">NOW PLAYING</div>
                    <div class="no-metadata">No metadata available</div>
                `;
                displayStationIcon();
                // Reset current track
                currentTrack = { title: null, artist: null, album: null, artworkUrl: null };
                updateLikeButton();
                // Update media session with station info when no metadata
                if (currentStation) {
                    updateMediaSession(
                        currentStation.name,
                        '',
                        '',
                        currentStation.icon_url
                    );
                }
                return;
            }
            
            const streamTitle = metadata.StreamTitle || '';
            let title = 'Unknown';
            let artist = '';
            let album = '';
            
            // Check if metadata is in structured attribute format: title="...",artist="..."
            const titleMatch = streamTitle.match(/title=["']([^"']+)["']/i);
            const artistMatch = streamTitle.match(/artist=["']([^"']+)["']/i);
            
            if (titleMatch || artistMatch) {
                // Structured format detected
                title = titleMatch ? titleMatch[1].trim() : 'Unknown';
                artist = artistMatch ? artistMatch[1].trim() : '';
            } else {
                // Helper function to clean metadata text (remove XML attributes from iHeart and similar stations)
                function cleanMetadataText(text) {
                    if (!text) return '';
                    
                    // First, check if the text starts with text="..." pattern and extract the value
                    const textMatch = text.match(/^text=["']([^"']+)["']/i);
                    if (textMatch) {
                        return textMatch[1].trim();
                    }
                    
                    // Otherwise, remove everything after common attribute patterns like text=", song_spot=", etc.
                    // This matches patterns like: text="..." or attribute="value" or attribute='value'
                    const cleaned = text.replace(/\s+(text|song_spot|spotInstanceId|length|MediaBaseId|TAID|TPID|cartcutId|amgArtworkURL|spEventID|[a-zA-Z_]+)=["'][^"']*["'].*$/i, '');
                    return cleaned.trim();
                }
                
                // Traditional format: "Artist - Title"
                if (streamTitle.includes(' - ')) {
                    const parts = streamTitle.split(' - ');
                    artist = cleanMetadataText(parts[0].trim());
                    title = cleanMetadataText(parts[1].trim());
                } else {
                    title = cleanMetadataText(streamTitle);
                }
            }
            
            // Update current track
            currentTrack.title = title;
            currentTrack.artist = artist;
            currentTrack.album = album;
            
            metadataDiv.innerHTML = `
                <div class="now-playing-label">NOW PLAYING</div>
                <div class="song-title">${escapeHtml(title)}</div>
                ${artist ? `<div class="artist-name">${escapeHtml(artist)}</div>` : ''}
                ${album ? `<div class="album-name">${escapeHtml(album)}</div>` : ''}
                <button class="like-btn" id="likeBtn" onclick="toggleLikeTrack()">â™¡</button>
            `;
            
            // Update like button state
            updateLikeButton();
            
            // Try to fetch album art
            fetchAlbumArt(title, artist);
        }
        
        // Fetch album art from iTunes or MusicBrainz
        async function fetchAlbumArt(title, artist) {
            if (!artist || !title) {
                displayStationIcon();
                return;
            }
            
            const useItunes = document.getElementById('useItunesApi').checked;
            
            if (useItunes) {
                await fetchAlbumArtItunes(title, artist);
            } else {
                await fetchAlbumArtMusicBrainz(title, artist);
            }
        }
        
        // Fetch album art from iTunes API
        async function fetchAlbumArtItunes(title, artist) {
            try {
                // Clean up artist name - take first artist if multiple
                let cleanArtist = artist.split(/[\/&]|feat\.|ft\./i)[0].trim();
                
                console.log(`Searching iTunes for: "${cleanArtist}" - "${title}"`);
                
                const query = encodeURIComponent(`${cleanArtist} ${title}`);
                const itunesUrl = `https://itunes.apple.com/search?term=${query}&entity=song&limit=1`;
                
                const response = await fetch(itunesUrl);
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    const result = data.results[0];
                    // iTunes returns 100x100 by default, we can get higher res by replacing with 600x600
                    let artUrl = result.artworkUrl100;
                    if (artUrl) {
                        artUrl = artUrl.replace('100x100', '600x600');
                        
                        // Store artwork URL in current track
                        currentTrack.artworkUrl = artUrl;
                        
                        const img = new Image();
                        img.onload = () => {
                            artworkContainer.innerHTML = `<img src="${artUrl}" alt="Album Art" class="album-art">`;
                            updateMediaSession(title, artist, result.collectionName || '', artUrl);
                        };
                        img.onerror = () => {
                            displayStationIcon();
                        };
                        img.src = artUrl;
                        return;
                    }
                }
            } catch (error) {
                console.error('Error fetching album art from iTunes:', error);
            }
            
            currentTrack.artworkUrl = null;
            displayStationIcon();
            updateMediaSession(title, artist, '', null);
        }
        
        // Fetch album art from MusicBrainz/Cover Art Archive
        async function fetchAlbumArtMusicBrainz(title, artist) {
            try {
                // Clean up artist name - take first artist if multiple (separated by /, feat., &, etc.)
                let cleanArtist = artist.split(/[\/&]|feat\.|ft\./i)[0].trim();
                
                // Log what we're searching for (helps with debugging)
                console.log(`Searching MusicBrainz for: "${cleanArtist}" - "${title}"`);
                
                const query = encodeURIComponent(`${cleanArtist} ${title}`);
                const mbUrl = `https://musicbrainz.org/ws/2/recording/?query=${query}&fmt=json&limit=1`;
                
                const mbResponse = await fetch(mbUrl);
                const mbData = await mbResponse.json();
                
                if (mbData.recordings && mbData.recordings.length > 0) {
                    const recording = mbData.recordings[0];
                    if (recording.releases && recording.releases.length > 0) {
                        const releaseId = recording.releases[0].id;
                        const artUrl = `https://coverartarchive.org/release/${releaseId}/front-500`;
                        
                        const img = new Image();
                        img.onload = () => {
                            artworkContainer.innerHTML = `<img src="${artUrl}" alt="Album Art" class="album-art">`;
                            updateMediaSession(title, artist, '', artUrl);
                        };
                        img.onerror = () => {
                            displayStationIcon();
                        };
                        img.src = artUrl;
                        return;
                    }
                }
            } catch (error) {
                console.error('Error fetching album art from MusicBrainz:', error);
            }
            
            displayStationIcon();
            updateMediaSession(title, artist, '', null);
        }
        
        // Update Media Session API
        function updateMediaSession(title, artist, album, artworkUrl) {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: title || 'Unknown Track',
                    artist: artist || (currentStation ? currentStation.name : 'Radio Stream'),
                    album: album || '',
                    artwork: artworkUrl ? [
                        { src: artworkUrl, sizes: '600x600', type: 'image/jpeg' }
                    ] : (currentStation && currentStation.icon_url ? [
                        { src: currentStation.icon_url, sizes: '512x512', type: 'image/png' }
                    ] : [])
                });
            }
        }
        
        // Setup Media Session handlers
        function setupMediaSessionHandlers() {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.setActionHandler('play', () => {
                    // Always trigger play/pause button when play is pressed
                    // This handles both starting from stopped and resuming from paused
                    if (!isPlaying || isPaused) {
                        playPauseBtn.click();
                    }
                });
                
                navigator.mediaSession.setActionHandler('pause', () => {
                    if (isPlaying && !isPaused) {
                        playPauseBtn.click();
                    }
                });
                
                navigator.mediaSession.setActionHandler('stop', () => {
                    if (isPlaying || isPaused) {
                        isPaused = false;
                        stopAllPlayers();
                        isPlaying = false;
                        updateStatus('Stopped', 'stopped');
                        updatePlayPauseButton(false);
                    }
                });
                
                navigator.mediaSession.setActionHandler('nexttrack', () => {
                    if (stations.length > 0 && currentStation) {
                        const currentIndex = stations.findIndex(s => s.id === currentStation.id);
                        const nextIndex = (currentIndex + 1) % stations.length;
                        selectStation(stations[nextIndex]);
                        setTimeout(() => playPauseBtn.click(), 500);
                    }
                });
                
                navigator.mediaSession.setActionHandler('previoustrack', () => {
                    if (stations.length > 0 && currentStation) {
                        const currentIndex = stations.findIndex(s => s.id === currentStation.id);
                        const prevIndex = currentIndex > 0 ? currentIndex - 1 : stations.length - 1;
                        selectStation(stations[prevIndex]);
                        setTimeout(() => playPauseBtn.click(), 500);
                    }
                });
            }
        }
        
        // ======================
        // PLAYER CONTROLS
        // ======================
        
        // Helper function to detect if URL is HLS stream
        function isHLSStream(url) {
            return url && (url.includes('.m3u8') || url.includes('m3u8'));
        }
        
        // Helper function to stop all players
        function stopAllPlayers() {
            isPaused = false; // Reset pause state when actually stopping
            if (player) {
                try {
                    player.stop();
                } catch (e) {
                    console.error('Error stopping Icecast player:', e);
                }
                player = null;
            }
            
            if (hlsPlayer) {
                try {
                    hlsPlayer.destroy();
                } catch (e) {
                    console.error('Error destroying HLS player:', e);
                }
                hlsPlayer = null;
            }
            
            if (audioElement) {
                try {
                    audioElement.pause();
                    audioElement.src = '';
                } catch (e) {
                    console.error('Error stopping audio element:', e);
                }
            }
        }
        
        // Helper function to play HLS stream
        async function playHLSStream(streamUrl) {
            return new Promise((resolve, reject) => {
                // Create audio element if it doesn't exist
                if (!audioElement) {
                    audioElement = new Audio();
                    audioElement.crossOrigin = 'anonymous';
                }
                
                if (Hls.isSupported()) {
                    hlsPlayer = new Hls({
                        enableWorker: true,
                        lowLatencyMode: true,
                        backBufferLength: 90
                    });
                    
                    hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
                        audioElement.play()
                            .then(() => {
                                isPlaying = true;
                                updateStatus('Playing (HLS Stream)', 'playing');
                                metadataDiv.innerHTML = `
                                    <div class="now-playing-label">NOW PLAYING</div>
                                    <div class="no-metadata">HLS stream - metadata not available</div>
                                `;
                                // Update media session with station info for HLS streams
                                if (currentStation) {
                                    updateMediaSession(
                                        currentStation.name,
                                        '',
                                        '',
                                        currentStation.icon_url
                                    );
                                }
                                resolve();
                            })
                            .catch(reject);
                    });
                    
                    hlsPlayer.on(Hls.Events.ERROR, (event, data) => {
                        if (data.fatal) {
                            console.error('HLS fatal error:', data);
                            reject(new Error(`HLS Error: ${data.type}`));
                        }
                    });
                    
                    hlsPlayer.loadSource(streamUrl);
                    hlsPlayer.attachMedia(audioElement);
                    
                } else if (audioElement.canPlayType('application/vnd.apple.mpegurl')) {
                    // Native HLS support (Safari)
                    audioElement.src = streamUrl;
                    audioElement.play()
                        .then(() => {
                            isPlaying = true;
                            updateStatus('Playing (HLS Stream)', 'playing');
                            metadataDiv.innerHTML = `
                                <div class="now-playing-label">NOW PLAYING</div>
                                <div class="no-metadata">HLS stream - metadata not available</div>
                            `;
                            // Update media session with station info for HLS streams
                            if (currentStation) {
                                updateMediaSession(
                                    currentStation.name,
                                    '',
                                    '',
                                    currentStation.icon_url
                                );
                            }
                            resolve();
                        })
                        .catch(reject);
                } else {
                    reject(new Error('HLS not supported in this browser'));
                }
            });
        }
        
        // Function to update button state
        function updatePlayPauseButton(playing) {
            if (playing) {
                playPauseBtn.classList.remove('btn-play');
                playPauseBtn.classList.add('btn-pause');
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'block';
            } else {
                playPauseBtn.classList.remove('btn-pause');
                playPauseBtn.classList.add('btn-play');
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
            }
        }
        
        // Play/Pause button handler
        playPauseBtn.addEventListener('click', async () => {
            // If playing, pause (not stop)
            if (isPlaying && !isPaused) {
                isPaused = true;
                if (audioElement) {
                    audioElement.pause();
                } else if (player && player.audioElement) {
                    player.audioElement.pause();
                }
                isPlaying = false;
                updateStatus('Paused', 'stopped');
                updatePlayPauseButton(false);
                return;
            }
            
            // If paused, resume
            if (isPaused) {
                isPaused = false;
                if (audioElement && audioElement.src) {
                    audioElement.play();
                    isPlaying = true;
                    updateStatus('Playing', 'playing');
                    updatePlayPauseButton(true);
                    return;
                } else if (player && player.audioElement && player.audioElement.src) {
                    player.audioElement.play();
                    isPlaying = true;
                    updateStatus('Playing', 'playing');
                    updatePlayPauseButton(true);
                    return;
                }
            }
            
            // If not playing and not paused, start playing
            const rawUrl = currentStation 
                ? (selectedQuality === 'low' && currentStation.url_low ? currentStation.url_low : 
                   selectedQuality === 'high' && currentStation.url_high ? currentStation.url_high : currentStation.url)
                : null;
            
            if (!rawUrl) {
                updateStatus('Please select a station', 'error');
                return;
            }
            
            // Stop any existing players (reset pause state)
            isPaused = false;
            stopAllPlayers();
            
            playPauseBtn.disabled = true;
            updateStatus('Connecting...', 'loading');
            artworkContainer.innerHTML = `<div class="album-art-placeholder">ðŸ”„</div>`;
            metadataDiv.innerHTML = `
                <div class="now-playing-label">NOW PLAYING</div>
                <div class="no-metadata">Loading stream...</div>
            `;
            
            // Check if it's an HLS stream
            if (isHLSStream(rawUrl)) {
                try {
                    console.log('Detected HLS stream (.m3u8), using HLS player');
                    await playHLSStream(rawUrl);
                    return;
                } catch (error) {
                    console.error('HLS playback failed:', error);
                    updateStatus('Error: Unable to play HLS stream', 'error');
                    playPauseBtn.disabled = false;
                    updatePlayPauseButton(false);
                    return;
                }
            }
            
            // Regular Icecast/Shoutcast stream handling
            const useCorsProxy = document.getElementById('globalCorsProxy').checked;
            
            let attempts = [
                { url: rawUrl, cors: false, metadata: ['icy', 'ogg'] },
                { url: rawUrl, cors: false, metadata: ['ogg'] },
                { url: rawUrl, cors: false, metadata: [] },
                { url: rawUrl, cors: true, metadata: ['ogg'] },
                { url: rawUrl, cors: true, metadata: [] }
            ];
            
            if (useCorsProxy) {
                attempts = [
                    { url: rawUrl, cors: true, metadata: ['icy', 'ogg'] },
                    { url: rawUrl, cors: true, metadata: ['ogg'] },
                    { url: rawUrl, cors: true, metadata: [] },
                    { url: rawUrl, cors: false, metadata: ['ogg'] },
                    { url: rawUrl, cors: false, metadata: [] }
                ];
            }
            
            let lastError = null;
            
            for (let i = 0; i < attempts.length; i++) {
                const attempt = attempts[i];
                const streamUrl = attempt.cors 
                    ? `https://corsproxy.io/?${encodeURIComponent(attempt.url)}`
                    : attempt.url;
                
                try {
                    if (i > 0) {
                        const metadataDesc = attempt.metadata.includes('icy') ? 'full metadata' :
                                           attempt.metadata.includes('ogg') ? 'OGG metadata' : 'no metadata';
                        const statusMsg = attempt.cors 
                            ? `Retrying with CORS proxy (${metadataDesc})...`
                            : `Retrying (${metadataDesc})...`;
                        updateStatus(statusMsg, 'loading');
                    }
                    
                    player = new IcecastMetadataPlayer(streamUrl, {
                        metadataTypes: attempt.metadata,
                        enableLogging: false,
                        
                        onMetadata: (metadata) => {
                            displayMetadata(metadata);
                        },
                        
                        onPlay: () => {
                            isPlaying = true;
                            const statusMsg = attempt.metadata.length === 0 
                                ? 'Playing (no metadata available)'
                                : 'Playing';
                            updateStatus(statusMsg, 'playing');
                            updatePlayPauseButton(true);
                            playPauseBtn.disabled = false;
                            // Update media session with station info when starting stream
                            if (currentStation && attempt.metadata.length === 0) {
                                updateMediaSession(
                                    currentStation.name,
                                    '',
                                    '',
                                    currentStation.icon_url
                                );
                            }
                        },
                        
                        onStop: () => {
                            // Don't update UI if we're just pausing
                            if (isPaused) {
                                return;
                            }
                            isPlaying = false;
                            updateStatus('Stopped', 'stopped');
                            playPauseBtn.disabled = false;
                            updatePlayPauseButton(false);
                            displayStationIcon();
                            metadataDiv.innerHTML = `
                                <div class="now-playing-label">NOW PLAYING</div>
                                <div class="no-metadata">Select a station to start streaming</div>
                            `;
                        },
                        
                        onError: (error) => {
                            console.error(`Player error on attempt ${i + 1}:`, error);
                        },
                        
                        bufferLength: 3,
                        retryTimeout: 5,
                        retryDelayRate: 0.5,
                        retryDelayMin: 1,
                        retryDelayMax: 10
                    });
                    
                    await player.play();
                    return;
                    
                } catch (error) {
                    console.error(`Attempt ${i + 1}/${attempts.length} failed:`, error.message);
                    lastError = error;
                    
                    if (player) {
                        try {
                            player.stop();
                        } catch (e) {}
                    }
                    
                    if (i < attempts.length - 1) {
                        continue;
                    }
                }
            }
            
            console.error('All connection attempts failed');
            isPlaying = false;
            updateStatus('Error: Unable to connect to stream. Try enabling/disabling CORS proxy.', 'error');
            playPauseBtn.disabled = false;
            updatePlayPauseButton(false);
        });
        
        // Allow Enter key to search
        stationSearch.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && filteredStations.length === 1) {
                selectStation(filteredStations[0]);
            }
        });
        
        // ======================
        // VIEW TOGGLE FUNCTIONS
        // ======================
        
        // Toggle station view mode
        function toggleStationView() {
            stationViewMode = stationViewMode === 'list' ? 'grid' : 'list';
            updateStationViewUI();
            renderStationList();
        }
        
        // Update station view toggle UI
        function updateStationViewUI() {
            if (stationViewMode === 'list') {
                stationViewIcon.textContent = 'âŠž';
                stationViewText.textContent = 'Grid';
            } else {
                stationViewIcon.textContent = 'â˜°';
                stationViewText.textContent = 'List';
            }
        }
        
        // Toggle playlist view mode
        function togglePlaylistView() {
            playlistViewMode = playlistViewMode === 'list' ? 'grid' : 'list';
            updatePlaylistViewUI();
            renderPlaylistsList();
        }
        
        // Update playlist view toggle UI
        function updatePlaylistViewUI() {
            if (playlistViewMode === 'list') {
                playlistViewIcon.textContent = 'âŠž';
                playlistViewText.textContent = 'Grid';
            } else {
                playlistViewIcon.textContent = 'â˜°';
                playlistViewText.textContent = 'List';
            }
        }
        
        // Toggle playlist station view mode (for Most Recent, Most Played, and custom playlists)
        function togglePlaylistStationView() {
            playlistStationViewMode = playlistStationViewMode === 'list' ? 'grid' : 'list';
            updatePlaylistStationViewUI();
            renderPlaylistStations();
        }
        
        // Update playlist station view toggle UI
        function updatePlaylistStationViewUI() {
            if (playlistStationViewMode === 'list') {
                playlistStationViewIcon.textContent = 'âŠž';
                playlistStationViewText.textContent = 'Grid';
            } else {
                playlistStationViewIcon.textContent = 'â˜°';
                playlistStationViewText.textContent = 'List';
            }
        }
        
        // Add event listeners for view toggle buttons
        if (stationViewToggle) {
            stationViewToggle.addEventListener('click', toggleStationView);
        }
        if (playlistViewToggle) {
            playlistViewToggle.addEventListener('click', togglePlaylistView);
        }
        if (playlistStationViewToggle) {
            playlistStationViewToggle.addEventListener('click', togglePlaylistStationView);
        }
        
        // ======================
        // INITIALIZATION
        // ======================
        
        console.log('=== INITIALIZATION STARTING ===');
        console.log('Supabase initialized:', !!supabase);
        
        // Initialize quality modal options
        document.querySelectorAll('.quality-option-modal').forEach(option => {
            if (option.dataset.quality !== 'standard') {
                option.classList.add('disabled');
            }
        });
        
        console.log('About to call loadStations()');
        
        // Load stations from Supabase on startup
        loadStations();
        loadPlaylists();
        
        console.log('loadStations() and loadPlaylists() called');
        
        // Setup Media Session handlers
        setupMediaSessionHandlers();
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.station-menu-btn') && 
                !e.target.closest('.station-dropdown') &&
                !e.target.closest('.playlist-menu-btn') &&
                !e.target.closest('.playlist-dropdown') &&
                !e.target.closest('.filter-btn') &&
                !e.target.closest('.filter-dropdown')) {
                document.querySelectorAll('.station-dropdown, .playlist-dropdown, .filter-dropdown').forEach(dropdown => {
                    dropdown.classList.remove('active');
                });
                // Also close any open submenus
                document.querySelectorAll('.dropdown-submenu').forEach(submenu => {
                    submenu.classList.remove('active');
                });
            }
        });
    </script>
    
    <!-- Service Worker Registration -->
    <script>
        // Register service worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Use relative path for GitHub Pages subdirectory support
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('ServiceWorker registered:', registration.scope);
                        
                        // Listen for messages from the service worker
                        navigator.serviceWorker.addEventListener('message', (event) => {
                            if (event.data && event.data.type === 'CACHE_CLEARED') {
                                console.log('Service worker cache cleared successfully');
                            }
                        });
                        
                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New service worker available, prompt user to refresh
                                    if (confirm('New version available! Reload to update?')) {
                                        newWorker.postMessage({ type: 'SKIP_WAITING' });
                                        window.location.reload();
                                    }
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.log('ServiceWorker registration failed:', error);
                    });
                
                // Handle service worker updates
                let refreshing;
                navigator.serviceWorker.addEventListener('controllerchange', () => {
                    if (refreshing) return;
                    refreshing = true;
                    window.location.reload();
                });
            });
        }
        
        // Install prompt handling
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing
            e.preventDefault();
            deferredPrompt = e;
            
            // Optionally, show an install button
            console.log('App can be installed');
        });
        
        window.addEventListener('appinstalled', () => {
            console.log('PWA was installed');
            deferredPrompt = null;
        });
    </script>
    <br>
    <br>
</body>
</html>
